<html>
<head>
    <link rel="Stylesheet" type="text/css" href="style.css" />
    <title>Databases</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <script type="text/javascript" async src="https://cdn.jsdelivr.net/gh/mathjax/MathJax@2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
    <a href="index.html">Index</a>
    <hr>
    <div class="content">
    
<div id="Databases"><h1 id="Databases" class="header"><a href="#Databases">Databases</a></h1></div>
<p>
Slides are <a href="http://joerg.endrullis.de/databases/">here</a>
</p>

<div id="Contents" class="toc"><h1 id="Contents">Contents</a></h2></div>
<ul>
<li>
<a href="Databases.html#Databases-What's probably on the exam">What's probably on the exam</a>

<li>
<a href="Databases.html#Databases-Introduction">Introduction</a>

<ul>
<li>
<a href="Databases.html#Databases-Introduction-Relational databases">Relational databases</a>

<li>
<a href="Databases.html#Databases-Introduction-Database management system">Database management system</a>

<li>
<a href="Databases.html#Databases-Introduction-SQL: Structured Query Language">SQL: Structured Query Language</a>

</ul>
<li>
<a href="Databases.html#Databases-The relational model">The relational model</a>

<ul>
<li>
<a href="Databases.html#Databases-The relational model-Concepts: schema, state">Concepts: schema, state</a>

<ul>
<li>
<a href="Databases.html#Databases-The relational model-Concepts: schema, state-Data types">Data types</a>

<li>
<a href="Databases.html#Databases-The relational model-Concepts: schema, state-Relation schema">Relation schema</a>

<li>
<a href="Databases.html#Databases-The relational model-Concepts: schema, state-Tuples">Tuples</a>

<li>
<a href="Databases.html#Databases-The relational model-Concepts: schema, state-Database states">Database states</a>

</ul>
<li>
<a href="Databases.html#Databases-The relational model-Null values">Null values</a>

<li>
<a href="Databases.html#Databases-The relational model-Constraints">Constraints</a>

<li>
<a href="Databases.html#Databases-The relational model-Keys">Keys</a>

<ul>
<li>
<a href="Databases.html#Databases-The relational model-Keys-Foreign keys">Foreign keys</a>

</ul>
</ul>
<li>
<a href="Databases.html#Databases-Database design: Conceptual models">Database design: Conceptual models</a>

<ul>
<li>
<a href="Databases.html#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML">Conceptual models: Entity-Relationship &amp; UML</a>

<ul>
<li>
<a href="Databases.html#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Entity sets">Entity sets</a>

<ul>
<li>
<a href="Databases.html#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Entity sets-Weak entity sets">Weak entity sets</a>

</ul>
<li>
<a href="Databases.html#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Relationship sets">Relationship sets</a>

<li>
<a href="Databases.html#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Is-a (inheritance)">Is-a (inheritance)</a>

<li>
<a href="Databases.html#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Aggregation">Aggregation</a>

<li>
<a href="Databases.html#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Summary">Summary</a>

</ul>
<li>
<a href="Databases.html#Databases-Database design: Conceptual models-UML vs ER">UML vs ER</a>

</ul>
<li>
<a href="Databases.html#Databases-Conceptual to relational models">Conceptual to relational models</a>

<li>
<a href="Databases.html#Databases-SQL Overview">SQL Overview</a>

<ul>
<li>
<a href="Databases.html#Databases-SQL Overview-Basics">Basics</a>

<li>
<a href="Databases.html#Databases-SQL Overview-Subqueries &amp; non-monotonic constructs">Subqueries &amp; non-monotonic constructs</a>

</ul>
<li>
<a href="Databases.html#Databases-Aggregations">Aggregations</a>

<li>
<a href="Databases.html#Databases-Union, conditionals">Union, conditionals</a>

<li>
<a href="Databases.html#Databases-Order by">Order by</a>

<li>
<a href="Databases.html#Databases-Joins">Joins</a>

<li>
<a href="Databases.html#Databases-Relational normal forms">Relational normal forms</a>

<ul>
<li>
<a href="Databases.html#Databases-Relational normal forms-Functional dependencies">Functional dependencies</a>

<ul>
<li>
<a href="Databases.html#Databases-Relational normal forms-Functional dependencies-What is a functional dependency?">What is a functional dependency?</a>

<li>
<a href="Databases.html#Databases-Relational normal forms-Functional dependencies-Working with functional dependencies">Working with functional dependencies</a>

<li>
<a href="Databases.html#Databases-Relational normal forms-Functional dependencies-How to determine keys">How to determine keys</a>

<li>
<a href="Databases.html#Databases-Relational normal forms-Functional dependencies-Determinants">Determinants</a>

<li>
<a href="Databases.html#Databases-Relational normal forms-Functional dependencies-Consequences of bad database design">Consequences of bad database design</a>

</ul>
<li>
<a href="Databases.html#Databases-Relational normal forms-Normal forms">Normal forms</a>

<ul>
<li>
<a href="Databases.html#Databases-Relational normal forms-Normal forms-Boyce-Codd Normal Form (BCNF)">Boyce-Codd Normal Form (BCNF)</a>

<ul>
<li>
<a href="Databases.html#Databases-Relational normal forms-Normal forms-Boyce-Codd Normal Form (BCNF)-Splitting relations">Splitting relations</a>

<li>
<a href="Databases.html#Databases-Relational normal forms-Normal forms-Boyce-Codd Normal Form (BCNF)-Synthesis">Synthesis</a>

</ul>
<li>
<a href="Databases.html#Databases-Relational normal forms-Normal forms-Third normal form (3NF)">Third normal form (3NF)</a>

<ul>
<li>
<a href="Databases.html#Databases-Relational normal forms-Normal forms-Third normal form (3NF)-Synthesis">Synthesis</a>

</ul>
</ul>
</ul>
</ul>

<div id="Databases-What's probably on the exam"><h2 id="What's probably on the exam" class="header"><a href="#Databases-What's probably on the exam">What's probably on the exam</a></h2></div>
<p>
probably on exam:
</p>
<ul>
<li>
compute cover {attribute}+ -- needed everywhere

<li>
determine all minimal keys

<li>
find 'canonical' (minimal) set of FDs:

<ul>
<li>
use for BCNF decomposition -- splitting

<li>
3NF synthesis algorithm

</ul>
<li>
definitions of 4NF and multivalued FDs

</ul>

<div id="Databases-Introduction"><h2 id="Introduction" class="header"><a href="#Databases-Introduction">Introduction</a></h2></div>
<p>
database: collection of data with
</p>
<ul>
<li>
logical structure

<li>
specific semantics

<li>
specific group of users

</ul>

<p>
Why not in files? There's no query language, a weak logical structure, no efficient access, almost no protection from data loss, no parallel access control.
</p>

<p>
ANSI SPARC architecture stores data in three levels:
</p>
<ol>
<li>
View level: application programs hide details of data types. Hide information for privacy/security

<li>
Logical level ('conceptual schema'): describes data and relations among data

<li>
Physical level: how data is stored, in disk pages, index structures, whatever else.

</ol>

<div id="Databases-Introduction-Relational databases"><h3 id="Relational databases" class="header"><a href="#Databases-Introduction-Relational databases">Relational databases</a></h3></div>
<p>
view and logical levels are data representations in relations/tables
</p>

<p>
a row is a tuple record. the order of the elements of the tuples doesn't matter.
</p>

<p>
a database instance is a 'snapshot' of a database at a certain point in time.
</p>

<p>
the database schema is the structure of the database - the relations and constraints.
</p>

<p>
constraints:
</p>
<ul>
<li>
primary key (would be underlined) uniquely identifies a row in a table (<code>customer(id, name, street, city)</code>)

<li>
a foreign key that points to a record in a different table (<code>account(depository → customer, accountnr)</code>)

<li>
data types, constrained data types

<li>
columns constraints (e.g. unique, nullability, counter)

<li>
check constraints (logical expression for a domain)

</ul>

<p>
create an entity relationship model in UML:
</p>

<p>
<img src="img-databases/entity-relationship-model.png" alt="Entity relationship model" />
</p>

<p>
then translate that into relations
</p>

<div id="Databases-Introduction-Database management system"><h3 id="Database management system" class="header"><a href="#Databases-Introduction-Database management system">Database management system</a></h3></div>
<p>
database management system (DBMS) allows:
</p>
<ul>
<li>
create, modify database

<li>
query data using query language (retrieve)

<li>
support persistent storage of large amounts of data

<li>
allow durability and recovery

<li>
control access to data by users in parallel, without unexpected interactions among users (isolation) or partial actions (atomicity)

</ul>

<p>
multiple users, concurrent access. transactions have ACID properties:
</p>
<ul>
<li>
Atomicity: transaction executes fully or not at all (commit/abort)

<li>
Consistency: database remains in a consistent state where all integrity constraints hold

<li>
Isolation: multiple users can modify database at same time but will not see each other's partial actions

<li>
Durability: when a transaction is successfully committed, modified data is persistent regardless of disk crashes

</ul>

<p>
DBMS have data independence and duplication avoidance.
</p>
<ul>
<li>
Logical independence: logical schema doesn't depend on views

<li>
Physical independence: changing physical schema doesn't break the logical schema

</ul>


<div id="Databases-Introduction-SQL: Structured Query Language"><h3 id="SQL: Structured Query Language" class="header"><a href="#Databases-Introduction-SQL: Structured Query Language">SQL: Structured Query Language</a></h3></div>
<p>
SQL is declarative data manipulation language. The user says which conditions the retrieved data has to fulfill.
</p>

<p>
It's more concise than imperative languages, thus easier to maintain and cheaper to develop programs in it.
</p>

<p>
Users usually don't have to think about efficiency, the DBMS will manage that.
</p>

<p>
Creating a table with constraints:
</p>

<pre>
CREATE TABLE solved (
    id INT AUTO_INCREMENT,
    name VARCHAR(40) NOT NULL,
    homework NUMERIC(2) NOT NULL,
    points NUMERIC(2) NOT NULL CHECK (points &lt;= 10),
    PRIMARY KEY (id)
);
</pre>

<p>
Creating a view:
</p>

<pre>
CREATE VIEW solved_homework AS
    SELECT id, name, homework FROM solved;
</pre>

<div id="Databases-The relational model"><h2 id="The relational model" class="header"><a href="#Databases-The relational model">The relational model</a></h2></div>
<div id="Databases-The relational model-Concepts: schema, state"><h3 id="Concepts: schema, state" class="header"><a href="#Databases-The relational model-Concepts: schema, state">Concepts: schema, state</a></h3></div>
<p>
<img src="img-databases/database-schema-tree.png" alt="Database schema tree" />
</p>

<div id="Databases-The relational model-Concepts: schema, state-Data types"><h4 id="Data types" class="header"><a href="#Databases-The relational model-Concepts: schema, state-Data types">Data types</a></h4></div>
<p>
all table entries are data values that conform to some selection of data types.
</p>

<p>
example data types:
</p>
<ul>
<li>
strings:

<ul>
<li>
<code>VARCHAR(n)</code> strings up to n characters, use this if you know a certain maximum length

<li>
<code>TEXT</code> variable length up to 2 GB (but does not always take up 2 GB)

</ul>
<li>
numbers:

<ul>
<li>
<code>INT</code> integer

<li>
<code>NUMERIC(n)</code> decimal number with n digits

</ul>
<li>
date and time

<li>
binary data, like a <code>BLOB</code> (binary large object)

</ul>

<p>
domain <code>val(D)</code> of a type D is the set of possible values for that type
</p>

<p>
with SQL, we can create our own application-specific domains (new data types). examples:
</p>
<ul>
<li>
<code>CREATE DOMAIN EXNUM AS NUMERIC(2)</code>

<li>
<code>CREATE DOMAIN EXNUM AS NUMERIC(2) CHECK(VALUE &gt; 0)</code>

</ul>

<div id="Databases-The relational model-Concepts: schema, state-Relation schema"><h4 id="Relation schema" class="header"><a href="#Databases-The relational model-Concepts: schema, state-Relation schema">Relation schema</a></h4></div>
<p>
relation schema s (schema of single relation) defines:
</p>
<ul>
<li>
finite sequence A₁..An of distinct attribute names

<li>
for each attribute Ai a data type (domain) Di

</ul>

<p>
written as: s = { A₁ : D₁, ..., An : Dn }
</p>

<p>
SQL notation:
</p>

<pre>
CREATE TABLE exercises 
    (CAT    CHAR(1),
     ENO    NUMERIC(2),
     TOPIC  VARCHAR(40),
     MAXPT  NUMERIC(2))
</pre>

<p>
a relational database schema S defines:
</p>
<ul>
<li>
finite set of relation names {R₁, ..., Rm}

<li>
for every relation R a relation schema sch(R)

<li>
a set of C integrity constraints

</ul>

<p>
so S = ({R₁, ..., Rm}, sch, C)
</p>

<div id="Databases-The relational model-Concepts: schema, state-Tuples"><h4 id="Tuples" class="header"><a href="#Databases-The relational model-Concepts: schema, state-Tuples">Tuples</a></h4></div>
<p>
used to formalize table rows.
so e.g. in table exercises: <code>(’H’, 1, ’Rel.Alg.’, 10)</code>
</p>

<div id="Databases-The relational model-Concepts: schema, state-Database states"><h4 id="Database states" class="header"><a href="#Databases-The relational model-Concepts: schema, state-Database states">Database states</a></h4></div>
<p>
let a database schema ({R₁, ..., Rm}, schema, C) be given.
</p>

<p>
a database state I for this database schema defines for every relation name Ri to a finite set of tuples I(Ri) w.r.t the relation schema Schema(Ri)
</p>

<div id="Databases-The relational model-Null values"><h3 id="Null values" class="header"><a href="#Databases-The relational model-Null values">Null values</a></h3></div>
<p>
relational model allows missing attribute values.
</p>

<p>
these are represented by <code>NULL</code>. not the same as 0 or an empty string.
</p>

<p>
used to model scenarios like:
</p>
<ul>
<li>
a value exists IRL but is not known

<li>
no value exists

<li>
attribute is not applicable

<li>
any value will do

</ul>

<p>
without null values, you'd have to split a relation into specific relations, like <code>student_with_email</code> and <code>student_without_email</code>. or the users would have to make up a fake value, which would not be uniform and you'd have no idea how to query.
</p>

<p>
problems:
</p>
<ul>
<li>
no clear semantics, since null values can be used in many scenarios

<li>
SQL has three-valued logic (true, false, unknown), so if you want to check for null, you have to say <code>WHERE A IS NULL</code>

</ul>

<p>
so declaring many attributes as NOT NULL simplifies the program, but only do that if you're sure that there's always a value.
</p>

<div id="Databases-The relational model-Constraints"><h3 id="Constraints" class="header"><a href="#Databases-The relational model-Constraints">Constraints</a></h3></div>
<p>
the database should be an image of the relevant subset of the real world. plain definition of tables often allows too many database states.
</p>

<p>
Integrity constraints (IC): conditions which every database state has to satisfy, restricting the set of possible database states.
</p>

<p>
In <code>CREATE TABLE</code>, possible constraints:
</p>
<ul>
<li>
<code>NOT NULL</code>: no value in this column can be null

<li>
<code>Keys</code>: each key value can only appear once

<li>
<code>Foreign keys</code>: values in a column must appear as key values in another table

<li>
<code>CHECK</code>: column values have to satisfy a given predicate

</ul>

<p>
Why specify constraints:
</p>
<ul>
<li>
some protection against data input errors

<li>
document knowledge about database states

<li>
enforce law/company standards

<li>
protect against inconsistency

<li>
simplify queries in programs

</ul>

<div id="Databases-The relational model-Keys"><h3 id="Keys" class="header"><a href="#Databases-The relational model-Keys">Keys</a></h3></div>
<p>
key of relation R is attribute A that uniquely identifies tuples in R. this refers to all possible database states, not just the current one.
</p>

<p>
key constraint is satisfied in database state iff all tuples have different values for A.
</p>

<p>
once something is declared as a key, the DBMS refuses insertion of tuples with duplicate key values.. this refers to all possible database states, not just the current one.
</p>

<p>
keys can consist of several attributes, then they are composite keys. if columns A,B form a composite key, there cannot be two tuples t ≠ u which agree in both attributes. keys should never change.
</p>

<p>
a key constraint becomes weaker (less restrictive) if attributes are added to it.
</p>

<p>
a key is minimal if no attribute can be removed without destroying the key constraint.
</p>

<p>
a relation may have more than one minimal key. one is the primary key, which cannot be null. other keys are alternate/secondary.
</p>

<p>
choosing a primary key: single simple attribute, never updated
</p>

<div id="Databases-The relational model-Keys-Foreign keys"><h4 id="Foreign keys" class="header"><a href="#Databases-The relational model-Keys-Foreign keys">Foreign keys</a></h4></div>
<p>
use key attributes to uniquely reference a tuple, like a pointer. denoted with arrows:
</p>

<pre>
RESULTS (SID → STUDENTS,
        (CAT, ENO) → EXERCISES,
        POINTS)
        STUDENTS (SID,FIRST,LAST,EMAIL)
        EXERCISES (CAT,ENO,TOPIC,MAXPT)
</pre>

<p>
to refer from relation R to tuples of S, add primary key attributes of S to attributes of R. only stable if the logical 'address' of a tuple does not change.
</p>

<p>
implements a one-to-many relationship.
</p>

<p>
an existence guarantee is needed.
</p>

<p>
foreign key constraints in SQL:
</p>

<pre>
CREATE TABLE RESULTS (
    ...
    FOREIGN KEY (SID) REFERENCES STUDENTS(SID)
)
</pre>

<p>
this ensures that every referenced row exists, which ensures referential integrity of the database.
</p>

<p>
these operations violate the constraints:
</p>
<ul>
<li>
insertion into table with foreign key without matching referenced tuple. DBMS rejects update.

<li>
deletion from table if the tuple is referenced via foreign key. either DBMS rejects, both are deleted (cascade), or foreign key is set to null.

</ul>

<p>
only keys may be referenced. a table with composite key must be referenced by composite key that has same number of attributes. 
</p>

<div id="Databases-Database design: Conceptual models"><h2 id="Database design: Conceptual models" class="header"><a href="#Databases-Database design: Conceptual models">Database design: Conceptual models</a></h2></div>
<p>
Three phases:
</p>
<ul>
<li>
conceptual:

<ul>
<li>
what do we store

<li>
how are the elements related to each other

<li>
what are the constraints

<li>
models: Entity/Relationship, UML

</ul>
<li>
logical:

<ul>
<li>
transform conceptual schema into the schema supported by the database

<li>
models: relational model

</ul>
<li>
physical:

<ul>
<li>
design indices, table distribution, buffer sizes, etc.

<li>
try to maximise performance of the final system

</ul>
</ul>

<div id="Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML"><h3 id="Conceptual models: Entity-Relationship &amp; UML" class="header"><a href="#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML">Conceptual models: Entity-Relationship &amp; UML</a></h3></div>
<p>
<img src="img-databases/er-diagram.png" alt="ER diagram" />
</p>

<p>
static, models the structure and not operations. no methods or functions.
</p>

<ul>
<li>
rectangles represent entity sets

<li>
ellipses represent attributes

<ul>
<li>
double line - multivalued attributes 

<li>
dashed line - derived attributes

</ul>
<li>
diamonds are relationship sets

<li>
lines link attributes and relationship sets to entity sets

<li>
underline indicates primary key attributes

</ul>

<div id="Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Entity sets"><h4 id="Entity sets" class="header"><a href="#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Entity sets">Entity sets</a></h4></div>
<p>
entity is an abstract object (person, company, event..)
</p>

<p>
entitties have attributes (names, addresses, ...)
</p>

<p>
entity set is is a collection of similar entities (those sharing the same attributes).
</p>

<p>
represented by a set of attributes - descriptive properties possessed by all entities. the domain is set of permitted values for each attribute.
</p>

<p>
attribute types:
</p>
<ul>
<li>
simple and composite (e.g. street is composed of street name and number)

<li>
number of values:

<ul>
<li>
single-valued: e.g. age of a person

<li>
multivalued: e.g. person can have multiple phone numbers

</ul>
<li>
derived attributes:

<ul>
<li>
can be computed from other attributes

<li>
e.g. age computed from date of birth

</ul>
</ul>

<div id="Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Entity sets-Weak entity sets"><h5 id="Weak entity sets" class="header"><a href="#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Entity sets-Weak entity sets">Weak entity sets</a></h5></div>
<p>
a weak entity set doesn't have a primary key. its existence depends on existence of an identifying entity set. 
</p>

<p>
there has to be a total, one-to-may relationship set from identifying to weak entity set, shown by double diamond.
</p>

<p>
discriminator: a partial key, distinguishing weak entity only in combination with identifying entity. denoted by dashed underline.
</p>

<p>
primary key of weak entity set is combination of discriminator and primary key of identifying entity set.
</p>

<div id="Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Relationship sets"><h4 id="Relationship sets" class="header"><a href="#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Relationship sets">Relationship sets</a></h4></div>
<p>
a relationship is association among several entities (a tuple (e₁, e₂, ...) of entities)
</p>

<p>
a relationship set is a set of relationship of same kind. i.e. a set of tuples (e₁, e₂, ...) where e₁ ∈ E₁, e₂ ∈ E₂, etc. Can have attributes.
</p>

<p>
example in UML with a relationship set <em>plays-in</em> and role indicators:
</p>

<p>
<img src="img-databases/relationship-set-example.png" alt="Relationship set example" />
</p>

<p>
cardinality limits express number of entities to which another entity can be associated via relationship set:
</p>
<ul>
<li>
0...1 means zero or one

<li>
1...1 means precisely one

<li>
0...* means any number

<li>
1...* means at least one

</ul>

<p>
if cardinalities are not given, the default is many-to-many.
</p>

<p>
total participation: every entity in the entity set participates in at least one relationship in the relationship set
</p>

<p>
partial participation: entities may not participate in any relationship in the set
</p>

<p>
degree of a relationship set is number of entity sets participating in the relationship.
</p>

<div id="Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Is-a (inheritance)"><h4 id="Is-a (inheritance)" class="header"><a href="#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Is-a (inheritance)">Is-a (inheritance)</a></h4></div>
<p>
lower-level entity sets are subgroups of the higher-level entity sets (e.g. an employee 'is a' person)
</p>

<p>
<img src="img-databases/is-a-example.png" alt="Is a example" />
</p>

<p>
lower-level entity sets inherit all attributes and relationships of the higher-level entity sets
</p>

<p>
you can go top-down and find subgroups (specialisation) or bottom-up and combine entity sets (generalisation)
</p>

<p>
constraints:
</p>
<ul>
<li>
membership: value-based, assigns entity to subclass based on attribute values

<li>
disjointness: an entity can belong to at most one subclass (default is overlapping, where it can belong to multiple)

<li>
completeness: total specialisation, each superclass entity must belong to a subclass

</ul>

<div id="Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Aggregation"><h4 id="Aggregation" class="header"><a href="#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Aggregation">Aggregation</a></h4></div>
<p>
treat relationship set as an abstract entity. allows relations between relations.
</p>

<div id="Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Summary"><h4 id="Summary" class="header"><a href="#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Summary">Summary</a></h4></div>
<p>
<img src="img-databases/er-symbols-1.png" alt="ER symbols 1" />
<img src="img-databases/er-symbols-2.png" alt="ER symbols 2" />
</p>


<div id="Databases-Database design: Conceptual models-UML vs ER"><h3 id="UML vs ER" class="header"><a href="#Databases-Database design: Conceptual models-UML vs ER">UML vs ER</a></h3></div>
<p>
attributes are shown within box of entity set, not as separate ellipses.
</p>

<p>
binary relationships are a line connecting entity sets, with name of relationship next to line.
</p>

<p>
if relationship set has attributes, name of relationship set is written in box along with attributes of relation; box is connected with dashed line to the relation line.
</p>

<p>
non-binary relationship sets are drawn with a diamond.
</p>

<p>
important differences:
</p>
<ul>
<li>
keys:

<ul>
<li>
ER supports keys with underlining

<li>
UML has no standard for keys

</ul>
<li>
aggregation:

<ul>
<li>
ER: treating relationship set as entity

<li>
UML: part-whole relation (non-exclusive composition)

</ul>
<li>
weak entities:

<ul>
<li>
ER: entities without own key

<li>
UML: composition is similar, but says nothing about keys

</ul>
</ul>

<div id="Databases-Conceptual to relational models"><h2 id="Conceptual to relational models" class="header"><a href="#Databases-Conceptual to relational models">Conceptual to relational models</a></h2></div>
<p>
entity sets and relationship sets are represented as tables
</p>
<ul>
<li>
name of table is name of entity/relationship set

<li>
columns (unique names) usually correspond to attributes

</ul>

<p>
a strong entity set becomes a table with columns for the attributes.
</p>

<p>
a weak entity set becomes table with:
</p>
<ul>
<li>
columns for the attributes

<li>
columns for the primary keys of the identifying entity

</ul>

<p>
many-to-many relationship set becomes table with:
</p>
<ul>
<li>
columns for attributes of relationship

<li>
columns for primary keys of participating entity sets

</ul>

<p>
many-to-(zero or one) relations can be represented by adding extra attribute/column to the many-side with primary key of one-side
</p>

<p>
for one-to-one relationship sets, either side can have the key of the other.
</p>

<p>
if participation is partial (0..1), replacing table by an attribute will lead to null values for those that don't participate.
</p>

<p>
if participation is total, foreign key should be <code>NOT NULL</code>.
</p>

<p>
tables for relationship sets linking weak entity sets to identifying entity set can always be eliminated.o
</p>

<p>
when translating sets to tables:
</p>
<ul>
<li>
every table should have a primary key

<li>
declared foreign key references for each relationship

<li>
declared whether foreign keys are nullable

<li>
declared unique if appropriate

</ul>

<p>
composite attributes are flattened out by creating separate column for each component attribute. 
</p>

<p>
multi-valued attribute A of entity set E is represented by separate table with:
</p>
<ul>
<li>
columns for primary key of E

<li>
column for attribute value

<li>
each single value of multi-valued attributes gets its own row

</ul>

<p>
Is-a to relational model:
</p>
<ul>
<li>
Method 1: hierarchy of tables

<ul>
<li>
table for higher-level entity set

<li>
table for each lower-level entity set (includes primary key of higher-level entity set &amp; local attributes)

</ul>
<li>
Method 2: many tables

<ul>
<li>
form table for each entity set with all local &amp; inherited attributes

<li>
if specialisation is total, we don't need table for generalised entity - table for generalised entity can be defined as view containing union of specialisation tables

</ul>
<li>
Method 3: one table with null values

<ul>
<li>
form a single table with all local and specialized attributes

</ul>
</ul>

<p>
recursive association: translates to foreign key that refers to the same table
</p>
<ul>
<li>
requires separate table with two foreign keys to parent table

</ul>

<div id="Databases-SQL Overview"><h2 id="SQL Overview" class="header"><a href="#Databases-SQL Overview">SQL Overview</a></h2></div>
<div id="Databases-SQL Overview-Basics"><h3 id="Basics" class="header"><a href="#Databases-SQL Overview-Basics">Basics</a></h3></div>
<p>
Basic query: <code>SELECT columns FROM table WHERE condition is true</code>
</p>

<p>
The <code>FROM</code> clause is like declaring variables that range over tuples of a relation:
</p>

<pre SQL>
SELECT  E.ENO, E.TOPIC  -- choose columns ENO, TOPIC
FROM    EXERCISES E     -- table exercises, E being an 'alias' for the current row
WHERE   E.CAT = 'H'     -- where the column CAT contains the value 'H'
</pre>

<p>
If name of tuple variable ('E' in the code above) is not given explicitly, the variable will have the name of the relation ('EXERCISES' in the code above).
</p>

<p>
A reference to attribute A of variable R may be written as <code>A</code> if R is <em>the only tuple variable</em> with an attribute named A.
</p>

<p>
It is almost always an error if there are two tuple variables that aren't linked via join conditions.
</p>

<p>
Don't join more tables than needed.
</p>

<p>
In some scenarios, we might have to consider more than one tuple of the same relation to get a result tuple.
</p>

<p>
Duplicates have to be explicitly eliminated, using <code>DISTINCT</code>.
</p>

<p>
Sufficient condition for superfluous DISTINCT, where K is set of attributes uniquely determined by result.
</p>
<ol>
<li>
Assume WHERE clause is a conjunction. Let K be the set of attributes in the SELECT clause.

<li>
Add to K attributes A s.t.:

<ul>
<li>
A = c for a constant c is in the WHERE clause

<li>
A = B for B ∈ K is in the WHERE clause

<li>
if K contains key of a tuple variable, add all attributes of that variable

</ul>
<li>
Repeat 2 until K is stable.

<li>
If K contains a key of every tuple variable listed under <code>FROM</code>, then <code>DISTINCT</code> is superfluous.

</ol>

<p>
Typical mistakes:
</p>
<ul>
<li>
missing join conditions

<li>
unnecessary joins (may slow down query)

<li>
self joins with incorrect treatment of multiple tuple variables over same relation, missing conditions

<li>
unexpected duplicates

<li>
unnecessary <code>DISTINCT</code>

</ul>

<div id="Databases-SQL Overview-Subqueries &amp; non-monotonic constructs"><h3 id="Subqueries &amp; non-monotonic constructs" class="header"><a href="#Databases-SQL Overview-Subqueries &amp; non-monotonic constructs">Subqueries &amp; non-monotonic constructs</a></h3></div>
<p>
monotonic: if further rows get inserted, the queries yield a superset of rows
</p>

<p>
non-monotonic: 'there is no', 'does not exist', 'for all', 'min/max'. testing whether or not a query yields an empty result.
</p>

<p>
example to select students without any homework result:
</p>

<pre SQL>
SELECT  FIRST, LAST
FROM    STUDENTS
WHERE   SID NOT IN (SELECT  SID
                    FROM    RESULTS
                    WHERE   CAT = 'H')
</pre>

<p>
conceptually, the subquery (<code>SELECT SID...</code>) is evaluated before main query.
</p>

<p>
constructs:
</p>
<ul>
<li>
<code>NOT IN</code>: something is not in result of subquery

<li>
<code>NOT EXISTS</code>: result of subquery is empty

<li>
"For all": 

<ul>
<li>
no universal quantifier in SQL, but you can use <code>EXISTS</code>. In logic, <code>∀X(φ) ↔ ¬∃ X (¬ φ)</code>.

<li>
common pattern is <code>∀X (φ₁ → φ₂)</code> becomes <code>¬∃ X (φ₁ ∧ ¬ φ₂)</code>

</ul>
</ul>

<p>
Comparing values:
</p>
<ul>
<li>
<code>ALL</code>: compare with all values in a set, has to be true for all

<li>
<code>ANY</code>/<code>SOME</code>: has to be true for at least some values in a set (also, <code>x IN s</code> == <code>x = ANY s</code>)

<li>
for both, subquery has to return a single column

<li>
comparisons with subquery results (<code>POINTS = (SELECT ...)</code>) must return a single row

</ul>

<div id="Databases-Aggregations"><h2 id="Aggregations" class="header"><a href="#Databases-Aggregations">Aggregations</a></h2></div>
<p>
A view declaration registers a query (not the result) under an identifier
</p>

<p>
Simple aggregation functions: COUNT, SUM, AVG, MAX, MIN
</p>

<p>
Restrictions:
</p>
<ul>
<li>
aggregations can't be nested

<li>
aggregations can't be used in the <code>WHERE</code> clause

<li>
if aggregation function is used, and there's no <code>GROUP BY</code>, attributes can't appear in the <code>SELECT</code>

</ul>

<p>
Null values and aggregations
</p>
<ul>
<li>
usually, they're ignored before the aggregation

<li>
<code>COUNT(*)</code> counts null values. it counts rows, not attribute values

</ul>

<p>
GROUP BY partitions tuples of a table into groups, based on value equality for the GROUP BY attributes.
It can never produce empty groups.
Aggregation functions are applied to groups separately.
Sequence of GROUP BY is not important.
</p>

<p>
<code>HAVING</code> is a way to filter out groups based on some property. E.g. <code>HAVING SUM(POINTS) &gt;= 18</code>. <code>HAVING</code> should <em>only</em> contain aggregation functions, not single attributes.
</p>

<div id="Databases-Union, conditionals"><h2 id="Union, conditionals" class="header"><a href="#Databases-Union, conditionals">Union, conditionals</a></h2></div>
<p>
<code>UNION</code> combines results of two queries. there's no other way to make one result column to draw from different tables/columns.  
subqueries must return tables with same number of columns and compatible data types.
<code>UNION</code> eliminates duplicates, <code>UNION ALL</code> concatenates and keeps duplicates.
</p>

<p>
Condition expressions can be used for stuff like:
</p>

<pre SQL>
SELECT CASE WHEN CAT = 'H' THEN 'Homework'
            WHEN CAT = 'M' then 'Midterm'
            WHEN CAT = 'F' THEN 'Final'
            ELSE 'Unknown category' END,
        ENO, POINTS
FROM STUDENTS S, RESULTS R
WHERE S.SID = R.SID
AND S.FIRST = 'Ann' AND S.LAST = 'SMITH'
</pre>

<p>
To replace a null value, you can do the following (same result):
</p>
<ul>
<li>
<code>CASE WHEN x IS NOT NULL THEN x ELSE y END</code>

<li>
<code>COALESCE (x, y)</code>

</ul>

<div id="Databases-Order by"><h2 id="Order by" class="header"><a href="#Databases-Order by">Order by</a></h2></div>
<p>
<code>ORDER BY</code> allows list of sorting criteria.
Can specify multiple attribute names:
</p>
<ul>
<li>
second attribute adds ordering in lexicographic order

<li>
you can sort in ASC or DESC order

</ul>

<p>
May not be applied to a subquery.
</p>

<div id="Databases-Joins"><h2 id="Joins" class="header"><a href="#Databases-Joins">Joins</a></h2></div>
<p>
Types:
</p>
<ul>
<li>
<code>[INNER] JOIN</code>: usual join, eliminates tuples without a partner

<li>
<code>LEFT JOIN</code>: preserves rows of left table

<li>
<code>RIGHT JOIN</code>: preserves rows of right table

<li>
<code>FULL JOIN</code>: preserves rows of both tables

<li>
<code>CROSS JOIN</code>: Cartesian product in all combinations

</ul>

<p>
Join predicates:
</p>
<ul>
<li>
NATURAL: yields comparison of columns with same name

<li>
USING (A1, ..., An) appended

<li>
<span class="todo">TODO</span>: a bunch of stuff here that's not on the slides

</ul>

<div id="Databases-Relational normal forms"><h2 id="Relational normal forms" class="header"><a href="#Databases-Relational normal forms">Relational normal forms</a></h2></div>
<div id="Databases-Relational normal forms-Functional dependencies"><h3 id="Functional dependencies" class="header"><a href="#Databases-Relational normal forms-Functional dependencies">Functional dependencies</a></h3></div>
<p>
Functional dependencies are a generalization of keys. This theory defines when a relation is in normal form.
</p>

<p>
functional dependency: if two rows agree on a value in one column, they must also agree on the other column
e.g. here, functional dependency is <code>INAME → PHONE</code>, because phone number only depends on the instructor intuitively:
</p>

<p>
<img src="img-databases/fd-table-example.png" alt="FD table example" />
</p>

<p>
This is read as "<code>INAME</code> (functionally, uniquely) determines <code>PHONE</code>". 
</p>

<div id="Databases-Relational normal forms-Functional dependencies-What is a functional dependency?"><h4 id="What is a functional dependency?" class="header"><a href="#Databases-Relational normal forms-Functional dependencies-What is a functional dependency?">What is a functional dependency?</a></h4></div>
<ul>
<li>
like partial key, because it uniquely determines some attributes but not all

<li>
a constraint

<li>
A determinant is a 'minimal' functional dependency.

<li>
goal of database normalization is to turn functional dependencies into keys

</ul>

<p>
Keys are functional dependencies.
</p>

<p>
During database design, only unquestionable conditions should be used as functional dependencies.
</p>

<p>
It's usually bad database design if schema's relations violate normal form. If it's violated, data is stored redundantly and information about different concepts is intermixed.
</p>

<div id="Databases-Relational normal forms-Functional dependencies-Working with functional dependencies"><h4 id="Working with functional dependencies" class="header"><a href="#Databases-Relational normal forms-Functional dependencies-Working with functional dependencies">Working with functional dependencies</a></h4></div>
<p>
The database designer is not interested in all functional dependencies, but only in a representative functional dependency set that implies all others.
</p>

<p>
Implications of functional dependencies:
</p>
<ul>
<li>
If A→B and B→C, then A→C

<li>
A→A always holds

<li>
Armstrong axioms:

<ul>
<li>
If β ⊆ α, then α → β (reflexivity)

<li>
If α → β, then α ∪ γ → β ∪ γ (augmentation)

<li>
If α → β and β → γ, then α → γ (transitivity)

</ul>
</ul>

<p>
Computing the cover: for given set of attributes, see which they imply through FDs. Extended cover with those, and repeat.
</p>
<ul>
<li>
Cover of A ({A}+)? FDs A→B,C; B→E

<ul>
<li>
{A}+ ⇒ {A,B,C} ⇒ {A,B,C,E}

</ul>
</ul>

<p>
Checking whether a → β is implied by a functional dependency set:
</p>
<ol>
<li>
computer cover α⁺ of α:

<li>
check if β ⊆ α⁺:

<ul>
<li>
set of functional dependencies F implies α → β iff β ⊆ α⁺_F

</ul>
</ol>

<p>
example:
</p>

<p>
<img src="img-databases/example-to-check-fd.png" alt="Example to check functional dependency" />
</p>

<div id="Databases-Relational normal forms-Functional dependencies-How to determine keys"><h4 id="How to determine keys" class="header"><a href="#Databases-Relational normal forms-Functional dependencies-How to determine keys">How to determine keys</a></h4></div>
<p>
Determining a minimal key (slides 64-70)
</p>
<ul>
<li>
given:

<ul>
<li>
R(A,B,C,D)

<li>
FDs: A→C; C→B,D

</ul>
<li>
start with all attributes: {A,B,C,D}

<li>
For every attribute, see if we can remove it, which is possible if they are implied by an FD which is still in the attribute set.

<ul>
<li>
{A,B,C,D} ⇒ {A,C} (FD2) ⇒ {A} (FD1)

<li>
thus {A} is a minimal key

<li>
order matters, you can end up with different keys!

</ul>
</ul>

<p>
determining all minimal keys (slides 71-88)
</p>
<ul>
<li>
given:

<ul>
<li>
R(A,B,C,D)

<li>
FDs: A→C; C→B,D

</ul>
<li>
Start with set of candidates: attributes that imply and are not implied (not in any right hand side)

<ul>
<li>
{ {A} }

</ul>
<li>
Find cover of smallest candidate key

<ul>
<li>
{A} ⇒ {A,C} ⇒ {A,B,C,D}

</ul>
<li>
If does not contain all attributes, extend candidate with missing others and repeat.

<li>
edge case: if there are no attributes that aren't in ay right hand side, then candidates is empty set { {} } and you extend with every attribute like { {A}, {B}, ...} 

</ul>

<div id="Databases-Relational normal forms-Functional dependencies-Determinants"><h4 id="Determinants" class="header"><a href="#Databases-Relational normal forms-Functional dependencies-Determinants">Determinants</a></h4></div>
<p>
determinant: non-trivial, minimal functional dependency 
</p>

<p>
{A1, ..., An} is determinant for {B1, ..., Bm} if:
</p>
<ul>
<li>
functional dependency A1, ..., An → B1, ..., Bm holds; and

<li>
left-hand side is minimal (if any Ai is removed, then it does not hold); and

<li>
it is non-trivial, i.e. {B1, ..., Bm} not subset of {A1, ..., An}

</ul>

<div id="Databases-Relational normal forms-Functional dependencies-Consequences of bad database design"><h4 id="Consequences of bad database design" class="header"><a href="#Databases-Relational normal forms-Functional dependencies-Consequences of bad database design">Consequences of bad database design</a></h4></div>
<p>
usually if table contains an functional dependency that's not implied by a key, it's a sign of bad database design.
</p>

<p>
leads to:
</p>
<ul>
<li>
redundant storage of certain facts

<ul>
<li>
wastes storage space

<li>
hard to ensure integrity when updating, as all redundant copies need to be updated, wasting time

<li>
requires additional constraints to guarantee integrity

</ul>
<li>
insert, update, deletion anomalies

<ul>
<li>
update: when a single value needs to be changed, multiple tuples need to be updated, taking longer and maybe getting out of sync

<li>
insertion: when unrelated concepts are stored together in a single table

<li>
deletion: e.g. when last course of instructor is deleted, their phone number is lost

</ul>
</ul>

<p>
problem is that general FDs are not supported by relational databases. so you have to transform them into key constraints (database normalisation).
</p>

<div id="Databases-Relational normal forms-Normal forms"><h3 id="Normal forms" class="header"><a href="#Databases-Relational normal forms-Normal forms">Normal forms</a></h3></div>
<p>
Normal form types:
</p>
<ul>
<li>
Third Normal Form (3NF): standard relational normal form used in practice

<li>
Boyce-Codd Normal Form (BCNF): 

<ul>
<li>
a bit more restrictive, easier to define, better for intuition

<li>
BCNF requires that all functional dependencies are keys.

<li>
ensures that key constraints automatically satisfy all FDs, so no more constraints are needed

<li>
anomalies (update/insertion/deletion) don't occur

</ul>
</ul>

<p>
Normalisation algorithms can construct good relation schemas from attributes and functional dependencies. When an ER model is well designed, resulting derived relational tables will automatically be in BCNF.
</p>

<p>
First normal form (1NF):
</p>
<ul>
<li>
requires all table entries are atomic (not lists, sets, records, or relations)

<li>
all further normal forms assume that tables are in 1NF

</ul>

<div id="Databases-Relational normal forms-Normal forms-Boyce-Codd Normal Form (BCNF)"><h4 id="Boyce-Codd Normal Form (BCNF)" class="header"><a href="#Databases-Relational normal forms-Normal forms-Boyce-Codd Normal Form (BCNF)">Boyce-Codd Normal Form (BCNF)</a></h4></div>
<ul>
<li>
if all of its FDs are implied by its key constraints

<li>
in symbols:

<ul>
<li>
for every FD A1,...,An → B1,...,Bm of R, we have

<li>
either {B1,...,Bm} ⊆ {A1,...,An} (the FD is trivial)

<li>
or {A1,...,An} contains a key of R

</ul>
<li>
in short, if for every non-trivial functional dependency, left-hand side contains a key

</ul>
<blockquote>
<img src="img-databases/example-of-checking-bcnf.png" alt="Example of checking BCNF" />
</blockquote>

<div id="Databases-Relational normal forms-Normal forms-Boyce-Codd Normal Form (BCNF)-Splitting relations"><h5 id="Splitting relations" class="header"><a href="#Databases-Relational normal forms-Normal forms-Boyce-Codd Normal Form (BCNF)-Splitting relations">Splitting relations</a></h5></div>
<p>
If table R is not in BCNF, we can split it into two tables. You split based on violating FD.
</p>

<p>
Table decomposition:
</p>
<ul>
<li>
if FD A1,...,An → B1,...,Bm violates BCNF:

<ol>
<li>
create new relation S(A1,...,An,B1,...,Bm)

<li>
and remove B1,...,Bm from original relation R

</ol>
</ul>

<p>
Splitting has to be <span id="Databases-Relational normal forms-Normal forms-Boyce-Codd Normal Form (BCNF)-Splitting relations-lossless"></span><strong id="lossless">lossless</strong> so that you can reconstruct original relation by a join.
</p>

<p>
Decomposition theorem: split is guaranteed to be lossless if intersection of attributes of new tables is a key of at least one of them.
</p>

<p>
It's always possible to transform relation into BCNF by lossless splitting. The resulting schema can always represent all previously possible states, but it may be more general and allow states that do not exist in the old schema.
</p>

<p>
With computable columns, splitting the relation is not the right solution - instead, define a view with the computed column.
</p>

<p>
A good decomposition should guarantee preservation of FDs:
</p>
<ul>
<li>
and FD can refer only to attributes of a single relation

<li>
when splitting relation into two, there might be FDs that can't be expressed anymore (not preserved)

</ul>

<div id="Databases-Relational normal forms-Normal forms-Boyce-Codd Normal Form (BCNF)-Synthesis"><h5 id="Synthesis" class="header"><a href="#Databases-Relational normal forms-Normal forms-Boyce-Codd Normal Form (BCNF)-Synthesis">Synthesis</a></h5></div>
<p>
Determining canonical (minimal) set of FDs:
</p>
<ul>
<li>
given:

<ul>
<li>
R(A,B,C,D,E)

<li>
FDs: D→A; E→A,D; C,D→A; A,E→C; B→A,D,E

</ul>
<li>
Rewrite every FD as singular:

<ul>
<li>
D→A, E→A, E→D, C,D→A, A,E→C, B→A, B→D, B→E

</ul>
<li>
Minimise left hand side of every FD (aka is every FD minimal?)

<ul>
<li>
drop C from C,D→A because D→A

<li>
drop A from A,E→C because E→A

<li>
so: D→A, E→A, E→D, D→A, E→C, B→A, B→D, B→E

</ul>
<li>
Remove implied FDs (and trivial/duplicate) using lhs attributes (aka if we can determine rhs without the FD itself)

<ul>
<li>
D→A, E→D, E→C, B→E

</ul>
</ul>

<p>
BCNF synthesis (relation R, set of FDs for R):
</p>
<ol>
<li>
Determine canonical set of FDs

<ul>
<li>
e.g. D→A, E→D, E→C, B→E

</ul>
<li>
Maximise rhs of FDs

<ul>
<li>
{D}+ - D = {A}

<li>
\({E}_{-E}^+\) = {D,C,A}

<li>
\({B}_{-B}^+\) = {E,D,C,A}  ({B} is the minimal key in this case)

</ul>
<li>
Split on violating FDs. For each FD, remove the rhs from relations and add a new relation, with the lhs of that FD being the key.

</ol>

<div id="Databases-Relational normal forms-Normal forms-Third normal form (3NF)"><h4 id="Third normal form (3NF)" class="header"><a href="#Databases-Relational normal forms-Normal forms-Third normal form (3NF)">Third normal form (3NF)</a></h4></div>
<ul>
<li>
relation is in 3NF if for every non-trivial functional dependency:

<ul>
<li>
left-hand side contains a key

<li>
or righthand side is attribute of minimal key

</ul>
</ul>

<p>
retains all FDs, so more popular than BCNF. If we leave table in 3NF, we have non-key constraints - the FDs that are not implied by keys.
</p>

<div id="Databases-Relational normal forms-Normal forms-Third normal form (3NF)-Synthesis"><h5 id="Synthesis" class="header"><a href="#Databases-Relational normal forms-Normal forms-Third normal form (3NF)-Synthesis">Synthesis</a></h5></div>
<p>
Produces lossless decomposition of relation into 3NF that preserves FDs.
</p>

<ol>
<li>
Determine canonical set of FDs

<ul>
<li>
e.g. D→A, E→D, E→C, B→E

</ul>
<li>
Merge FDs with same lhs and create relations from them

<ul>
<li>
R1(<u>D</u>, A)

<li>
R2(<u>E</u>,C,D)

<li>
R3(<u>B</u>,E)

</ul>
<li>
Check if any of relations has key of original relation. If not, create a new relation with attributes of the minimal key.

<ul>
<li>
In this case, R(A,<u>B</u>,C,D,E); R3 has <u>B</u>, so don't need to do anything.

</ul>
<li>
For all pairs of created relations: are they contained in another relation? If yes, remove.

</ol>

    </div>
</body>
</html>
