<html>
<head>
    <link rel="Stylesheet" type="text/css" href="style.css" />
    <title>Databases</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <script type="text/javascript" async src="https://cdn.jsdelivr.net/gh/mathjax/MathJax@2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
    <a href="index.html">Index</a>
    <hr>
    <div class="content">
    
<div id="Databases"><h1 id="Databases" class="header"><a href="#Databases">Databases</a></h1></div>
<p>
Slides are <a href="http://joerg.endrullis.de/databases/">here</a>
</p>

<div id="Contents" class="toc"><h1 id="Contents">Contents</a></h2></div>
<ul>
<li>
<a href="Databases.html#Databases-Kind of a syllabus">Kind of a syllabus</a>

<li>
<a href="Databases.html#Databases-Introduction">Introduction</a>

<ul>
<li>
<a href="Databases.html#Databases-Introduction-Relational databases">Relational databases</a>

<li>
<a href="Databases.html#Databases-Introduction-Database management system">Database management system</a>

<li>
<a href="Databases.html#Databases-Introduction-SQL: Structured Query Language">SQL: Structured Query Language</a>

</ul>
<li>
<a href="Databases.html#Databases-The relational model">The relational model</a>

<ul>
<li>
<a href="Databases.html#Databases-The relational model-Concepts: schema, state">Concepts: schema, state</a>

<ul>
<li>
<a href="Databases.html#Databases-The relational model-Concepts: schema, state-Data types">Data types</a>

<li>
<a href="Databases.html#Databases-The relational model-Concepts: schema, state-Relation schema">Relation schema</a>

<li>
<a href="Databases.html#Databases-The relational model-Concepts: schema, state-Tuples">Tuples</a>

<li>
<a href="Databases.html#Databases-The relational model-Concepts: schema, state-Database states">Database states</a>

</ul>
<li>
<a href="Databases.html#Databases-The relational model-Null values">Null values</a>

<li>
<a href="Databases.html#Databases-The relational model-Constraints">Constraints</a>

<li>
<a href="Databases.html#Databases-The relational model-Keys">Keys</a>

<ul>
<li>
<a href="Databases.html#Databases-The relational model-Keys-Foreign keys">Foreign keys</a>

</ul>
</ul>
<li>
<a href="Databases.html#Databases-Database design: Conceptual models">Database design: Conceptual models</a>

<ul>
<li>
<a href="Databases.html#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML">Conceptual models: Entity-Relationship &amp; UML</a>

<ul>
<li>
<a href="Databases.html#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Entity sets">Entity sets</a>

<ul>
<li>
<a href="Databases.html#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Entity sets-Weak entity sets">Weak entity sets</a>

</ul>
<li>
<a href="Databases.html#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Relationship sets">Relationship sets</a>

<li>
<a href="Databases.html#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Is-a (inheritance)">Is-a (inheritance)</a>

<li>
<a href="Databases.html#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Aggregation">Aggregation</a>

<li>
<a href="Databases.html#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Summary">Summary</a>

</ul>
<li>
<a href="Databases.html#Databases-Database design: Conceptual models-UML vs ER">UML vs ER</a>

</ul>
<li>
<a href="Databases.html#Databases-Conceptual to relational models">Conceptual to relational models</a>

<li>
<a href="Databases.html#Databases-SQL Overview">SQL Overview</a>

<ul>
<li>
<a href="Databases.html#Databases-SQL Overview-Basics">Basics</a>

<li>
<a href="Databases.html#Databases-SQL Overview-Subqueries &amp; non-monotonic constructs">Subqueries &amp; non-monotonic constructs</a>

</ul>
<li>
<a href="Databases.html#Databases-Aggregations">Aggregations</a>

<li>
<a href="Databases.html#Databases-Union, conditionals">Union, conditionals</a>

<li>
<a href="Databases.html#Databases-Order by">Order by</a>

<li>
<a href="Databases.html#Databases-Joins">Joins</a>

<li>
<a href="Databases.html#Databases-Relational normal forms">Relational normal forms</a>

<ul>
<li>
<a href="Databases.html#Databases-Relational normal forms-Functional dependencies">Functional dependencies</a>

<ul>
<li>
<a href="Databases.html#Databases-Relational normal forms-Functional dependencies-What is a functional dependency?">What is a functional dependency?</a>

<li>
<a href="Databases.html#Databases-Relational normal forms-Functional dependencies-Working with functional dependencies">Working with functional dependencies</a>

<li>
<a href="Databases.html#Databases-Relational normal forms-Functional dependencies-How to determine keys">How to determine keys</a>

<li>
<a href="Databases.html#Databases-Relational normal forms-Functional dependencies-Determinants">Determinants</a>

<li>
<a href="Databases.html#Databases-Relational normal forms-Functional dependencies-Consequences of bad database design">Consequences of bad database design</a>

</ul>
<li>
<a href="Databases.html#Databases-Relational normal forms-Normal forms">Normal forms</a>

<ul>
<li>
<a href="Databases.html#Databases-Relational normal forms-Normal forms-Boyce-Codd Normal Form (BCNF)">Boyce-Codd Normal Form (BCNF)</a>

<ul>
<li>
<a href="Databases.html#Databases-Relational normal forms-Normal forms-Boyce-Codd Normal Form (BCNF)-Splitting relations">Splitting relations</a>

<li>
<a href="Databases.html#Databases-Relational normal forms-Normal forms-Boyce-Codd Normal Form (BCNF)-Synthesis">Synthesis</a>

</ul>
<li>
<a href="Databases.html#Databases-Relational normal forms-Normal forms-Third normal form (3NF)">Third normal form (3NF)</a>

<ul>
<li>
<a href="Databases.html#Databases-Relational normal forms-Normal forms-Third normal form (3NF)-Synthesis">Synthesis</a>

</ul>
</ul>
<li>
<a href="Databases.html#Databases-Relational normal forms-MVD &amp; 4NF">MVD &amp; 4NF</a>

<ul>
<li>
<a href="Databases.html#Databases-Relational normal forms-MVD &amp; 4NF-Multivalued dependencies (MVDs)">Multivalued dependencies (MVDs)</a>

<li>
<a href="Databases.html#Databases-Relational normal forms-MVD &amp; 4NF-Fourth Normal Form (4NF)">Fourth Normal Form (4NF)</a>

</ul>
<li>
<a href="Databases.html#Databases-Relational normal forms-Normal forms &amp; ER design">Normal forms &amp; ER design</a>

<li>
<a href="Databases.html#Databases-Relational normal forms-Denormalization">Denormalization</a>

</ul>
<li>
<a href="Databases.html#Databases-Transactions">Transactions</a>

<ul>
<li>
<a href="Databases.html#Databases-Transactions-Schedules">Schedules</a>

<li>
<a href="Databases.html#Databases-Transactions-Serializability">Serializability</a>

<li>
<a href="Databases.html#Databases-Transactions-Runtime serializability strategies">Runtime serializability strategies</a>

<ul>
<li>
<a href="Databases.html#Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking">Pessimistic: lock-based, two phase locking</a>

<ul>
<li>
<a href="Databases.html#Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Deadlock handling">Deadlock handling</a>

<li>
<a href="Databases.html#Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Cascading rollbacks">Cascading rollbacks</a>

<li>
<a href="Databases.html#Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Strict 2 phase locking">Strict 2 phase locking</a>

<li>
<a href="Databases.html#Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Preclaiming 2 phase locking">Preclaiming 2 phase locking</a>

<li>
<a href="Databases.html#Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Granularity of locking">Granularity of locking</a>

<li>
<a href="Databases.html#Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Optimising performance">Optimising performance</a>

<li>
<a href="Databases.html#Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Isolation levels">Isolation levels</a>

</ul>
<li>
<a href="Databases.html#Databases-Transactions-Runtime serializability strategies-Optimistic concurrency control">Optimistic concurrency control</a>

<ul>
<li>
<a href="Databases.html#Databases-Transactions-Runtime serializability strategies-Optimistic concurrency control-Validation">Validation</a>

<li>
<a href="Databases.html#Databases-Transactions-Runtime serializability strategies-Optimistic concurrency control-Multiversion concurrency control">Multiversion concurrency control</a>

</ul>
</ul>
</ul>
</ul>

<div id="Databases-Kind of a syllabus"><h2 id="Kind of a syllabus" class="header"><a href="#Databases-Kind of a syllabus">Kind of a syllabus</a></h2></div>
<p>
Here's what you should be able to do for each chapter (directly from slides).
</p>

<p>
Data modelling
</p>
<ul>
<li>
three phases of database design: conceptual, logical, physical

<li>
basic E/R concepts

<ul>
<li>
entities, attributes, relationships, 'is a', weak entity sets, aggregation

<li>
cardinality/participation constraints

</ul>
<li>
how UML corresponds with and differs from E/R

<ul>
<li>
differences: basic syntax, aggregation, key specifications

</ul>
<li>
how to make a conceptual model given a scenario (UML and ER)

</ul>

<p>
Conceptual to relational model
</p>
<ul>
<li>
how to translate a conceptual model to a relational model

<ul>
<li>
identifying keys

<li>
internal/external keys

<li>
(foreign) key constraints

<li>
multi-valued attributes

<li>
weak entity sets vs. composition

<li>
'is a'

<li>
representing cardinalities

<li>
recursive relationships

<li>
optimisation: removing relationship tables

</ul>
</ul>

<p>
Relational model:
</p>
<ul>
<li>
explain concepts of relational model:

<ul>
<li>
schemas, state, domains

<li>
read various notations for relational schema

</ul>
<li>
explain applications and problems of null values

<li>
explain integrity constraints and their importance

<li>
explain meaning of keys and foreign keys

<li>
develop simple relational schemas

</ul>

<p>
SQL:
</p>
<ul>
<li>
write advanced SQL queries (nested, multiple variables)

<li>
aggregation, grouping, union

<li>
be comfortable with various join variants

<li>
evaluated correctness and equivalence of SQL queries (including possible presence of duplicate result tuples)

</ul>

<p>
Relational normal forms:
</p>
<ul>
<li>
work with functional dependencies:

<ul>
<li>
define what they are

<li>
detect them in database schemas

<li>
decide implication, determine keys

</ul>
<li>
explain insert, update, delete anomalies

<li>
understand, explain, and use BCNF

<ul>
<li>
test a given relation for BCNF

<li>
transform a relation into BCNF

</ul>
<li>
understand, explain, and use 3NF

<ul>
<li>
test a given relation for 3NF

<li>
transform a relation into 3NF

</ul>
<li>
understand, explain MVDs and 4NF

<li>
detect normal form violations on the level of ER

<li>
explain when and how to denormalise a database schema

<li>
probably on exam:

<ul>
<li>
compute cover {attribute}+ -- needed everywhere

<li>
determine all minimal keys

<li>
find 'canonical' (minimal) set of FDs:

<ul>
<li>
use for BCNF decomposition -- splitting

<li>
3NF synthesis algorithm

</ul>
<li>
definitions of 4NF and multivalued FDs

</ul>
</ul>

<p>
Transactions:
</p>
<ul>
<li>
ACID properties, transactions

<li>
anomalies: lost update, dirty read, unrepeatable read, phantoms

<li>
transaction schedules, serializability, conflicts (rw/wr/ww)

<li>
conflict equivalent, conflict serializability

<li>
lock based concurrency control: 2 PL (strict, preclaiming)

<li>
cascading rollbacks, deadlocks, deadlock detection

<li>
cascadeless, recoverabl

<li>
granularity of locking, intention locks

<li>
SQL isolation levels: <code>READ UNCOMMITTED</code>, <code>READ COMMITTED</code>, <code>READ STBILITY</code>, <code>SERIALIZABLE</code>

<li>
optimistic concurrency approach

<li>
multiversion concurrency control, snapshot isolation

</ul>

<div id="Databases-Introduction"><h2 id="Introduction" class="header"><a href="#Databases-Introduction">Introduction</a></h2></div>
<p>
database: collection of data with
</p>
<ul>
<li>
logical structure

<li>
specific semantics

<li>
specific group of users

</ul>

<p>
Why not in files? There's no query language, a weak logical structure, no efficient access, almost no protection from data loss, no parallel access control.
</p>

<p>
ANSI SPARC architecture stores data in three levels:
</p>
<ol>
<li>
View level: application programs hide details of data types. Hide information for privacy/security

<li>
Logical level ('conceptual schema'): describes data and relations among data

<li>
Physical level: how data is stored, in disk pages, index structures, whatever else.

</ol>

<div id="Databases-Introduction-Relational databases"><h3 id="Relational databases" class="header"><a href="#Databases-Introduction-Relational databases">Relational databases</a></h3></div>
<p>
view and logical levels are data representations in relations/tables
</p>

<p>
a row is a tuple record. the order of the elements of the tuples doesn't matter.
</p>

<p>
a database instance is a 'snapshot' of a database at a certain point in time.
</p>

<p>
the database schema is the structure of the database - the relations and constraints.
</p>

<p>
constraints:
</p>
<ul>
<li>
primary key (would be underlined) uniquely identifies a row in a table (<code>customer(id, name, street, city)</code>)

<li>
a foreign key that points to a record in a different table (<code>account(depository → customer, accountnr)</code>)

<li>
data types, constrained data types

<li>
columns constraints (e.g. unique, nullability, counter)

<li>
check constraints (logical expression for a domain)

</ul>

<p>
create an entity relationship model in UML:
</p>

<p>
<img src="img-databases/entity-relationship-model.png" alt="Entity relationship model" />
</p>

<p>
then translate that into relations
</p>

<div id="Databases-Introduction-Database management system"><h3 id="Database management system" class="header"><a href="#Databases-Introduction-Database management system">Database management system</a></h3></div>
<p>
database management system (DBMS) allows:
</p>
<ul>
<li>
create, modify database

<li>
query data using query language (retrieve)

<li>
support persistent storage of large amounts of data

<li>
allow durability and recovery

<li>
control access to data by users in parallel, without unexpected interactions among users (isolation) or partial actions (atomicity)

</ul>

<p>
multiple users, concurrent access. transactions have ACID properties:
</p>
<ul>
<li>
Atomicity: transaction executes fully or not at all (commit/abort)

<li>
Consistency: database remains in a consistent state where all integrity constraints hold

<li>
Isolation: multiple users can modify database at same time but will not see each other's partial actions

<li>
Durability: when a transaction is successfully committed, modified data is persistent regardless of disk crashes

</ul>

<p>
DBMS have data independence and duplication avoidance.
</p>
<ul>
<li>
Logical independence: logical schema doesn't depend on views

<li>
Physical independence: changing physical schema doesn't break the logical schema

</ul>


<div id="Databases-Introduction-SQL: Structured Query Language"><h3 id="SQL: Structured Query Language" class="header"><a href="#Databases-Introduction-SQL: Structured Query Language">SQL: Structured Query Language</a></h3></div>
<p>
SQL is declarative data manipulation language. The user says which conditions the retrieved data has to fulfill.
</p>

<p>
It's more concise than imperative languages, thus easier to maintain and cheaper to develop programs in it.
</p>

<p>
Users usually don't have to think about efficiency, the DBMS will manage that.
</p>

<p>
Creating a table with constraints:
</p>

<pre>
CREATE TABLE solved (
    id INT AUTO_INCREMENT,
    name VARCHAR(40) NOT NULL,
    homework NUMERIC(2) NOT NULL,
    points NUMERIC(2) NOT NULL CHECK (points &lt;= 10),
    PRIMARY KEY (id)
);
</pre>

<p>
Creating a view:
</p>

<pre>
CREATE VIEW solved_homework AS
    SELECT id, name, homework FROM solved;
</pre>

<div id="Databases-The relational model"><h2 id="The relational model" class="header"><a href="#Databases-The relational model">The relational model</a></h2></div>
<div id="Databases-The relational model-Concepts: schema, state"><h3 id="Concepts: schema, state" class="header"><a href="#Databases-The relational model-Concepts: schema, state">Concepts: schema, state</a></h3></div>
<p>
<img src="img-databases/database-schema-tree.png" alt="Database schema tree" />
</p>

<div id="Databases-The relational model-Concepts: schema, state-Data types"><h4 id="Data types" class="header"><a href="#Databases-The relational model-Concepts: schema, state-Data types">Data types</a></h4></div>
<p>
all table entries are data values that conform to some selection of data types.
</p>

<p>
example data types:
</p>
<ul>
<li>
strings:

<ul>
<li>
<code>VARCHAR(n)</code> strings up to n characters, use this if you know a certain maximum length

<li>
<code>TEXT</code> variable length up to 2 GB (but does not always take up 2 GB)

</ul>
<li>
numbers:

<ul>
<li>
<code>INT</code> integer

<li>
<code>NUMERIC(n)</code> decimal number with n digits

</ul>
<li>
date and time

<li>
binary data, like a <code>BLOB</code> (binary large object)

</ul>

<p>
domain <code>val(D)</code> of a type D is the set of possible values for that type
</p>

<p>
with SQL, we can create our own application-specific domains (new data types). examples:
</p>
<ul>
<li>
<code>CREATE DOMAIN EXNUM AS NUMERIC(2)</code>

<li>
<code>CREATE DOMAIN EXNUM AS NUMERIC(2) CHECK(VALUE &gt; 0)</code>

</ul>

<div id="Databases-The relational model-Concepts: schema, state-Relation schema"><h4 id="Relation schema" class="header"><a href="#Databases-The relational model-Concepts: schema, state-Relation schema">Relation schema</a></h4></div>
<p>
relation schema s (schema of single relation) defines:
</p>
<ul>
<li>
finite sequence A₁..An of distinct attribute names

<li>
for each attribute Ai a data type (domain) Di

</ul>

<p>
written as: s = { A₁ : D₁, ..., An : Dn }
</p>

<p>
SQL notation:
</p>

<pre>
CREATE TABLE exercises
    (CAT    CHAR(1),
     ENO    NUMERIC(2),
     TOPIC  VARCHAR(40),
     MAXPT  NUMERIC(2))
</pre>

<p>
a relational database schema S defines:
</p>
<ul>
<li>
finite set of relation names {R₁, ..., Rm}

<li>
for every relation R a relation schema sch(R)

<li>
a set of C integrity constraints

</ul>

<p>
so S = ({R₁, ..., Rm}, sch, C)
</p>

<div id="Databases-The relational model-Concepts: schema, state-Tuples"><h4 id="Tuples" class="header"><a href="#Databases-The relational model-Concepts: schema, state-Tuples">Tuples</a></h4></div>
<p>
used to formalize table rows.
so e.g. in table exercises: <code>(’H’, 1, ’Rel.Alg.’, 10)</code>
</p>

<div id="Databases-The relational model-Concepts: schema, state-Database states"><h4 id="Database states" class="header"><a href="#Databases-The relational model-Concepts: schema, state-Database states">Database states</a></h4></div>
<p>
let a database schema ({R₁, ..., Rm}, schema, C) be given.
</p>

<p>
a database state I for this database schema defines for every relation name Ri to a finite set of tuples I(Ri) w.r.t the relation schema Schema(Ri)
</p>

<div id="Databases-The relational model-Null values"><h3 id="Null values" class="header"><a href="#Databases-The relational model-Null values">Null values</a></h3></div>
<p>
relational model allows missing attribute values.
</p>

<p>
these are represented by <code>NULL</code>. not the same as 0 or an empty string.
</p>

<p>
used to model scenarios like:
</p>
<ul>
<li>
a value exists IRL but is not known

<li>
no value exists

<li>
attribute is not applicable

<li>
any value will do

</ul>

<p>
without null values, you'd have to split a relation into specific relations, like <code>student_with_email</code> and <code>student_without_email</code>. or the users would have to make up a fake value, which would not be uniform and you'd have no idea how to query.
</p>

<p>
problems:
</p>
<ul>
<li>
no clear semantics, since null values can be used in many scenarios

<li>
SQL has three-valued logic (true, false, unknown), so if you want to check for null, you have to say <code>WHERE A IS NULL</code>

</ul>

<p>
so declaring many attributes as NOT NULL simplifies the program, but only do that if you're sure that there's always a value.
</p>

<div id="Databases-The relational model-Constraints"><h3 id="Constraints" class="header"><a href="#Databases-The relational model-Constraints">Constraints</a></h3></div>
<p>
the database should be an image of the relevant subset of the real world. plain definition of tables often allows too many database states.
</p>

<p>
Integrity constraints (IC): conditions which every database state has to satisfy, restricting the set of possible database states.
</p>

<p>
In <code>CREATE TABLE</code>, possible constraints:
</p>
<ul>
<li>
<code>NOT NULL</code>: no value in this column can be null

<li>
<code>Keys</code>: each key value can only appear once

<li>
<code>Foreign keys</code>: values in a column must appear as key values in another table

<li>
<code>CHECK</code>: column values have to satisfy a given predicate

</ul>

<p>
Why specify constraints:
</p>
<ul>
<li>
some protection against data input errors

<li>
document knowledge about database states

<li>
enforce law/company standards

<li>
protect against inconsistency

<li>
simplify queries in programs

</ul>

<div id="Databases-The relational model-Keys"><h3 id="Keys" class="header"><a href="#Databases-The relational model-Keys">Keys</a></h3></div>
<p>
key of relation R is attribute A that uniquely identifies tuples in R. this refers to all possible database states, not just the current one.
</p>

<p>
key constraint is satisfied in database state iff all tuples have different values for A.
</p>

<p>
once something is declared as a key, the DBMS refuses insertion of tuples with duplicate key values.. this refers to all possible database states, not just the current one.
</p>

<p>
keys can consist of several attributes, then they are composite keys. if columns A,B form a composite key, there cannot be two tuples t ≠ u which agree in both attributes. keys should never change.
</p>

<p>
a key constraint becomes weaker (less restrictive) if attributes are added to it.
</p>

<p>
a key is minimal if no attribute can be removed without destroying the key constraint.
</p>

<p>
a relation may have more than one minimal key. one is the primary key, which cannot be null. other keys are alternate/secondary.
</p>

<p>
choosing a primary key: single simple attribute, never updated
</p>

<div id="Databases-The relational model-Keys-Foreign keys"><h4 id="Foreign keys" class="header"><a href="#Databases-The relational model-Keys-Foreign keys">Foreign keys</a></h4></div>
<p>
use key attributes to uniquely reference a tuple, like a pointer. denoted with arrows:
</p>

<pre>
RESULTS (SID → STUDENTS,
        (CAT, ENO) → EXERCISES,
        POINTS)
        STUDENTS (SID,FIRST,LAST,EMAIL)
        EXERCISES (CAT,ENO,TOPIC,MAXPT)
</pre>

<p>
to refer from relation R to tuples of S, add primary key attributes of S to attributes of R. only stable if the logical 'address' of a tuple does not change.
</p>

<p>
implements a one-to-many relationship.
</p>

<p>
an existence guarantee is needed.
</p>

<p>
foreign key constraints in SQL:
</p>

<pre>
CREATE TABLE RESULTS (
    ...
    FOREIGN KEY (SID) REFERENCES STUDENTS(SID)
)
</pre>

<p>
this ensures that every referenced row exists, which ensures referential integrity of the database.
</p>

<p>
these operations violate the constraints:
</p>
<ul>
<li>
insertion into table with foreign key without matching referenced tuple. DBMS rejects update.

<li>
deletion from table if the tuple is referenced via foreign key. either DBMS rejects, both are deleted (cascade), or foreign key is set to null.

</ul>

<p>
only keys may be referenced. a table with composite key must be referenced by composite key that has same number of attributes.
</p>

<div id="Databases-Database design: Conceptual models"><h2 id="Database design: Conceptual models" class="header"><a href="#Databases-Database design: Conceptual models">Database design: Conceptual models</a></h2></div>
<p>
Three phases:
</p>
<ul>
<li>
conceptual:

<ul>
<li>
what do we store

<li>
how are the elements related to each other

<li>
what are the constraints

<li>
models: Entity/Relationship, UML

</ul>
<li>
logical:

<ul>
<li>
transform conceptual schema into the schema supported by the database

<li>
models: relational model

</ul>
<li>
physical:

<ul>
<li>
design indices, table distribution, buffer sizes, etc.

<li>
try to maximise performance of the final system

</ul>
</ul>

<div id="Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML"><h3 id="Conceptual models: Entity-Relationship &amp; UML" class="header"><a href="#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML">Conceptual models: Entity-Relationship &amp; UML</a></h3></div>
<p>
<img src="img-databases/er-diagram.png" alt="ER diagram" />
</p>

<p>
static, models the structure and not operations. no methods or functions.
</p>

<ul>
<li>
rectangles represent entity sets

<li>
ellipses represent attributes

<ul>
<li>
double line - multivalued attributes

<li>
dashed line - derived attributes

</ul>
<li>
diamonds are relationship sets

<li>
lines link attributes and relationship sets to entity sets

<li>
underline indicates primary key attributes

</ul>

<div id="Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Entity sets"><h4 id="Entity sets" class="header"><a href="#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Entity sets">Entity sets</a></h4></div>
<p>
entity is an abstract object (person, company, event..)
</p>

<p>
entitties have attributes (names, addresses, ...)
</p>

<p>
entity set is is a collection of similar entities (those sharing the same attributes).
</p>

<p>
represented by a set of attributes - descriptive properties possessed by all entities. the domain is set of permitted values for each attribute.
</p>

<p>
attribute types:
</p>
<ul>
<li>
simple and composite (e.g. street is composed of street name and number)

<li>
number of values:

<ul>
<li>
single-valued: e.g. age of a person

<li>
multivalued: e.g. person can have multiple phone numbers

</ul>
<li>
derived attributes:

<ul>
<li>
can be computed from other attributes

<li>
e.g. age computed from date of birth

</ul>
</ul>

<div id="Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Entity sets-Weak entity sets"><h5 id="Weak entity sets" class="header"><a href="#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Entity sets-Weak entity sets">Weak entity sets</a></h5></div>
<p>
a weak entity set doesn't have a primary key. its existence depends on existence of an identifying entity set.
</p>

<p>
there has to be a total, one-to-may relationship set from identifying to weak entity set, shown by double diamond.
</p>

<p>
discriminator: a partial key, distinguishing weak entity only in combination with identifying entity. denoted by dashed underline.
</p>

<p>
primary key of weak entity set is combination of discriminator and primary key of identifying entity set.
</p>

<div id="Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Relationship sets"><h4 id="Relationship sets" class="header"><a href="#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Relationship sets">Relationship sets</a></h4></div>
<p>
a relationship is association among several entities (a tuple (e₁, e₂, ...) of entities)
</p>

<p>
a relationship set is a set of relationship of same kind. i.e. a set of tuples (e₁, e₂, ...) where e₁ ∈ E₁, e₂ ∈ E₂, etc. Can have attributes.
</p>

<p>
example in UML with a relationship set <em>plays-in</em> and role indicators:
</p>

<p>
<img src="img-databases/relationship-set-example.png" alt="Relationship set example" />
</p>

<p>
cardinality limits express number of entities to which another entity can be associated via relationship set:
</p>
<ul>
<li>
0...1 means zero or one

<li>
1...1 means precisely one

<li>
0...* means any number

<li>
1...* means at least one

</ul>

<p>
if cardinalities are not given, the default is many-to-many.
</p>

<p>
total participation: every entity in the entity set participates in at least one relationship in the relationship set
</p>

<p>
partial participation: entities may not participate in any relationship in the set
</p>

<p>
degree of a relationship set is number of entity sets participating in the relationship.
</p>

<div id="Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Is-a (inheritance)"><h4 id="Is-a (inheritance)" class="header"><a href="#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Is-a (inheritance)">Is-a (inheritance)</a></h4></div>
<p>
lower-level entity sets are subgroups of the higher-level entity sets (e.g. an employee 'is a' person)
</p>

<p>
<img src="img-databases/is-a-example.png" alt="Is a example" />
</p>

<p>
lower-level entity sets inherit all attributes and relationships of the higher-level entity sets
</p>

<p>
you can go top-down and find subgroups (specialisation) or bottom-up and combine entity sets (generalisation)
</p>

<p>
constraints:
</p>
<ul>
<li>
membership: value-based, assigns entity to subclass based on attribute values

<li>
disjointness: an entity can belong to at most one subclass (default is overlapping, where it can belong to multiple)

<li>
completeness: total specialisation, each superclass entity must belong to a subclass

</ul>

<div id="Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Aggregation"><h4 id="Aggregation" class="header"><a href="#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Aggregation">Aggregation</a></h4></div>
<p>
treat relationship set as an abstract entity. allows relations between relations.
</p>

<div id="Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Summary"><h4 id="Summary" class="header"><a href="#Databases-Database design: Conceptual models-Conceptual models: Entity-Relationship &amp; UML-Summary">Summary</a></h4></div>
<p>
<img src="img-databases/er-symbols-1.png" alt="ER symbols 1" />
<img src="img-databases/er-symbols-2.png" alt="ER symbols 2" />
</p>


<div id="Databases-Database design: Conceptual models-UML vs ER"><h3 id="UML vs ER" class="header"><a href="#Databases-Database design: Conceptual models-UML vs ER">UML vs ER</a></h3></div>
<p>
attributes are shown within box of entity set, not as separate ellipses.
</p>

<p>
binary relationships are a line connecting entity sets, with name of relationship next to line.
</p>

<p>
if relationship set has attributes, name of relationship set is written in box along with attributes of relation; box is connected with dashed line to the relation line.
</p>

<p>
non-binary relationship sets are drawn with a diamond.
</p>

<p>
important differences:
</p>
<ul>
<li>
keys:

<ul>
<li>
ER supports keys with underlining

<li>
UML has no standard for keys

</ul>
<li>
aggregation:

<ul>
<li>
ER: treating relationship set as entity

<li>
UML: part-whole relation (non-exclusive composition)

</ul>
<li>
weak entities:

<ul>
<li>
ER: entities without own key

<li>
UML: composition is similar, but says nothing about keys

</ul>
</ul>

<div id="Databases-Conceptual to relational models"><h2 id="Conceptual to relational models" class="header"><a href="#Databases-Conceptual to relational models">Conceptual to relational models</a></h2></div>
<p>
entity sets and relationship sets are represented as tables
</p>
<ul>
<li>
name of table is name of entity/relationship set

<li>
columns (unique names) usually correspond to attributes

</ul>

<p>
a strong entity set becomes a table with columns for the attributes.
</p>

<p>
a weak entity set becomes table with:
</p>
<ul>
<li>
columns for the attributes

<li>
columns for the primary keys of the identifying entity

</ul>

<p>
many-to-many relationship set becomes table with:
</p>
<ul>
<li>
columns for attributes of relationship

<li>
columns for primary keys of participating entity sets

</ul>

<p>
many-to-(zero or one) relations can be represented by adding extra attribute/column to the many-side with primary key of one-side
</p>

<p>
for one-to-one relationship sets, either side can have the key of the other.
</p>

<p>
if participation is partial (0..1), replacing table by an attribute will lead to null values for those that don't participate.
</p>

<p>
if participation is total, foreign key should be <code>NOT NULL</code>.
</p>

<p>
tables for relationship sets linking weak entity sets to identifying entity set can always be eliminated.o
</p>

<p>
when translating sets to tables:
</p>
<ul>
<li>
every table should have a primary key

<li>
declared foreign key references for each relationship

<li>
declared whether foreign keys are nullable

<li>
declared unique if appropriate

</ul>

<p>
composite attributes are flattened out by creating separate column for each component attribute.
</p>

<p>
multi-valued attribute A of entity set E is represented by separate table with:
</p>
<ul>
<li>
columns for primary key of E

<li>
column for attribute value

<li>
each single value of multi-valued attributes gets its own row

</ul>

<p>
Is-a to relational model:
</p>
<ul>
<li>
Method 1: hierarchy of tables

<ul>
<li>
table for higher-level entity set

<li>
table for each lower-level entity set (includes primary key of higher-level entity set &amp; local attributes)

</ul>
<li>
Method 2: many tables

<ul>
<li>
form table for each entity set with all local &amp; inherited attributes

<li>
if specialisation is total, we don't need table for generalised entity - table for generalised entity can be defined as view containing union of specialisation tables

</ul>
<li>
Method 3: one table with null values

<ul>
<li>
form a single table with all local and specialized attributes

</ul>
</ul>

<p>
recursive association: translates to foreign key that refers to the same table
</p>
<ul>
<li>
requires separate table with two foreign keys to parent table

</ul>

<div id="Databases-SQL Overview"><h2 id="SQL Overview" class="header"><a href="#Databases-SQL Overview">SQL Overview</a></h2></div>
<div id="Databases-SQL Overview-Basics"><h3 id="Basics" class="header"><a href="#Databases-SQL Overview-Basics">Basics</a></h3></div>
<p>
Basic query: <code>SELECT columns FROM table WHERE condition is true</code>
</p>

<p>
The <code>FROM</code> clause is like declaring variables that range over tuples of a relation:
</p>

<pre SQL>
SELECT  E.ENO, E.TOPIC  -- choose columns ENO, TOPIC
FROM    EXERCISES E     -- table exercises, E being an 'alias' for the current row
WHERE   E.CAT = 'H'     -- where the column CAT contains the value 'H'
</pre>

<p>
If name of tuple variable ('E' in the code above) is not given explicitly, the variable will have the name of the relation ('EXERCISES' in the code above).
</p>

<p>
A reference to attribute A of variable R may be written as <code>A</code> if R is <em>the only tuple variable</em> with an attribute named A.
</p>

<p>
It is almost always an error if there are two tuple variables that aren't linked via join conditions.
</p>

<p>
Don't join more tables than needed.
</p>

<p>
In some scenarios, we might have to consider more than one tuple of the same relation to get a result tuple.
</p>

<p>
Duplicates have to be explicitly eliminated, using <code>DISTINCT</code>.
</p>

<p>
Sufficient condition for superfluous DISTINCT, where K is set of attributes uniquely determined by result.
</p>
<ol>
<li>
Assume WHERE clause is a conjunction. Let K be the set of attributes in the SELECT clause.

<li>
Add to K attributes A s.t.:

<ul>
<li>
A = c for a constant c is in the WHERE clause

<li>
A = B for B ∈ K is in the WHERE clause

<li>
if K contains key of a tuple variable, add all attributes of that variable

</ul>
<li>
Repeat 2 until K is stable.

<li>
If K contains a key of every tuple variable listed under <code>FROM</code>, then <code>DISTINCT</code> is superfluous.

</ol>

<p>
Typical mistakes:
</p>
<ul>
<li>
missing join conditions

<li>
unnecessary joins (may slow down query)

<li>
self joins with incorrect treatment of multiple tuple variables over same relation, missing conditions

<li>
unexpected duplicates

<li>
unnecessary <code>DISTINCT</code>

</ul>

<div id="Databases-SQL Overview-Subqueries &amp; non-monotonic constructs"><h3 id="Subqueries &amp; non-monotonic constructs" class="header"><a href="#Databases-SQL Overview-Subqueries &amp; non-monotonic constructs">Subqueries &amp; non-monotonic constructs</a></h3></div>
<p>
monotonic: if further rows get inserted, the queries yield a superset of rows
</p>

<p>
non-monotonic: 'there is no', 'does not exist', 'for all', 'min/max'. testing whether or not a query yields an empty result.
</p>

<p>
example to select students without any homework result:
</p>

<pre SQL>
SELECT  FIRST, LAST
FROM    STUDENTS
WHERE   SID NOT IN (SELECT  SID
                    FROM    RESULTS
                    WHERE   CAT = 'H')
</pre>

<p>
conceptually, the subquery (<code>SELECT SID...</code>) is evaluated before main query.
</p>

<p>
constructs:
</p>
<ul>
<li>
<code>NOT IN</code>: something is not in result of subquery

<li>
<code>NOT EXISTS</code>: result of subquery is empty

<li>
"For all":

<ul>
<li>
no universal quantifier in SQL, but you can use <code>EXISTS</code>. In logic, <code>∀X(φ) ↔ ¬∃ X (¬ φ)</code>.

<li>
common pattern is <code>∀X (φ₁ → φ₂)</code> becomes <code>¬∃ X (φ₁ ∧ ¬ φ₂)</code>

</ul>
</ul>

<p>
Comparing values:
</p>
<ul>
<li>
<code>ALL</code>: compare with all values in a set, has to be true for all

<li>
<code>ANY</code>/<code>SOME</code>: has to be true for at least some values in a set (also, <code>x IN s</code> == <code>x = ANY s</code>)

<li>
for both, subquery has to return a single column

<li>
comparisons with subquery results (<code>POINTS = (SELECT ...)</code>) must return a single row

</ul>

<div id="Databases-Aggregations"><h2 id="Aggregations" class="header"><a href="#Databases-Aggregations">Aggregations</a></h2></div>
<p>
A view declaration registers a query (not the result) under an identifier
</p>

<p>
Simple aggregation functions: COUNT, SUM, AVG, MAX, MIN
</p>

<p>
Restrictions:
</p>
<ul>
<li>
aggregations can't be nested

<li>
aggregations can't be used in the <code>WHERE</code> clause

<li>
if aggregation function is used, and there's no <code>GROUP BY</code>, attributes can't appear in the <code>SELECT</code>

</ul>

<p>
Null values and aggregations
</p>
<ul>
<li>
usually, they're ignored before the aggregation

<li>
<code>COUNT(*)</code> counts null values. it counts rows, not attribute values

</ul>

<p>
GROUP BY partitions tuples of a table into groups, based on value equality for the GROUP BY attributes.
It can never produce empty groups.
Aggregation functions are applied to groups separately.
Sequence of GROUP BY is not important.
</p>

<p>
<code>HAVING</code> is a way to filter out groups based on some property. E.g. <code>HAVING SUM(POINTS) &gt;= 18</code>. <code>HAVING</code> should <em>only</em> contain aggregation functions, not single attributes.
</p>

<div id="Databases-Union, conditionals"><h2 id="Union, conditionals" class="header"><a href="#Databases-Union, conditionals">Union, conditionals</a></h2></div>
<p>
<code>UNION</code> combines results of two queries. there's no other way to make one result column to draw from different tables/columns.
subqueries must return tables with same number of columns and compatible data types.
<code>UNION</code> eliminates duplicates, <code>UNION ALL</code> concatenates and keeps duplicates.
</p>

<p>
Condition expressions can be used for stuff like:
</p>

<pre SQL>
SELECT CASE WHEN CAT = 'H' THEN 'Homework'
            WHEN CAT = 'M' then 'Midterm'
            WHEN CAT = 'F' THEN 'Final'
            ELSE 'Unknown category' END,
        ENO, POINTS
FROM STUDENTS S, RESULTS R
WHERE S.SID = R.SID
AND S.FIRST = 'Ann' AND S.LAST = 'SMITH'
</pre>

<p>
To replace a null value, you can do the following (same result):
</p>
<ul>
<li>
<code>CASE WHEN x IS NOT NULL THEN x ELSE y END</code>

<li>
<code>COALESCE (x, y)</code>

</ul>

<div id="Databases-Order by"><h2 id="Order by" class="header"><a href="#Databases-Order by">Order by</a></h2></div>
<p>
<code>ORDER BY</code> allows list of sorting criteria.
Can specify multiple attribute names:
</p>
<ul>
<li>
second attribute adds ordering in lexicographic order

<li>
you can sort in ASC or DESC order

</ul>

<p>
May not be applied to a subquery.
</p>

<div id="Databases-Joins"><h2 id="Joins" class="header"><a href="#Databases-Joins">Joins</a></h2></div>
<p>
Types:
</p>
<ul>
<li>
<code>[INNER] JOIN</code>: usual join, eliminates tuples without a partner

<li>
<code>LEFT JOIN</code>: preserves rows of left table

<li>
<code>RIGHT JOIN</code>: preserves rows of right table

<li>
<code>FULL JOIN</code>: preserves rows of both tables

<li>
<code>CROSS JOIN</code>: Cartesian product in all combinations

</ul>

<p>
Join predicates:
</p>
<ul>
<li>
NATURAL: yields comparison of columns with same name

<li>
USING (A1, ..., An) appended

<li>
<span class="todo">TODO</span>: a bunch of stuff here that's not on the slides

</ul>

<div id="Databases-Relational normal forms"><h2 id="Relational normal forms" class="header"><a href="#Databases-Relational normal forms">Relational normal forms</a></h2></div>
<div id="Databases-Relational normal forms-Functional dependencies"><h3 id="Functional dependencies" class="header"><a href="#Databases-Relational normal forms-Functional dependencies">Functional dependencies</a></h3></div>
<p>
Functional dependencies are a generalization of keys. This theory defines when a relation is in normal form.
</p>

<p>
functional dependency: if two rows agree on a value in one column, they must also agree on the other column
e.g. here, functional dependency is <code>INAME → PHONE</code>, because phone number only depends on the instructor intuitively:
</p>

<p>
<img src="img-databases/fd-table-example.png" alt="FD table example" />
</p>

<p>
This is read as "<code>INAME</code> (functionally, uniquely) determines <code>PHONE</code>".
</p>

<div id="Databases-Relational normal forms-Functional dependencies-What is a functional dependency?"><h4 id="What is a functional dependency?" class="header"><a href="#Databases-Relational normal forms-Functional dependencies-What is a functional dependency?">What is a functional dependency?</a></h4></div>
<ul>
<li>
like partial key, because it uniquely determines some attributes but not all

<li>
a constraint

<li>
A determinant is a 'minimal' functional dependency.

<li>
goal of database normalization is to turn functional dependencies into keys

</ul>

<p>
Keys are functional dependencies.
</p>

<p>
During database design, only unquestionable conditions should be used as functional dependencies.
</p>

<p>
It's usually bad database design if schema's relations violate normal form. If it's violated, data is stored redundantly and information about different concepts is intermixed.
</p>

<div id="Databases-Relational normal forms-Functional dependencies-Working with functional dependencies"><h4 id="Working with functional dependencies" class="header"><a href="#Databases-Relational normal forms-Functional dependencies-Working with functional dependencies">Working with functional dependencies</a></h4></div>
<p>
The database designer is not interested in all functional dependencies, but only in a representative functional dependency set that implies all others.
</p>

<p>
Implications of functional dependencies:
</p>
<ul>
<li>
If A→B and B→C, then A→C

<li>
A→A always holds

<li>
Armstrong axioms:

<ul>
<li>
If β ⊆ α, then α → β (reflexivity)

<li>
If α → β, then α ∪ γ → β ∪ γ (augmentation)

<li>
If α → β and β → γ, then α → γ (transitivity)

</ul>
</ul>

<p>
Computing the cover: for given set of attributes, see which they imply through FDs. Extended cover with those, and repeat.
</p>
<ul>
<li>
Cover of A ({A}+)? FDs A→B,C; B→E

<ul>
<li>
{A}+ ⇒ {A,B,C} ⇒ {A,B,C,E}

</ul>
</ul>

<p>
Checking whether a → β is implied by a functional dependency set:
</p>
<ol>
<li>
computer cover α⁺ of α:

<li>
check if β ⊆ α⁺:

<ul>
<li>
set of functional dependencies F implies α → β iff β ⊆ α⁺_F

</ul>
</ol>

<p>
example:
</p>

<p>
<img src="img-databases/example-to-check-fd.png" alt="Example to check functional dependency" />
</p>

<div id="Databases-Relational normal forms-Functional dependencies-How to determine keys"><h4 id="How to determine keys" class="header"><a href="#Databases-Relational normal forms-Functional dependencies-How to determine keys">How to determine keys</a></h4></div>
<p>
Determining a minimal key (slides 64-70)
</p>
<ul>
<li>
given:

<ul>
<li>
R(A,B,C,D)

<li>
FDs: A→C; C→B,D

</ul>
<li>
start with all attributes: {A,B,C,D}

<li>
For every attribute, see if we can remove it, which is possible if they are implied by an FD which is still in the attribute set.

<ul>
<li>
{A,B,C,D} ⇒ {A,C} (FD2) ⇒ {A} (FD1)

<li>
thus {A} is a minimal key

<li>
order matters, you can end up with different keys!

</ul>
</ul>

<p>
determining all minimal keys (slides 71-88)
</p>
<ul>
<li>
given:

<ul>
<li>
R(A,B,C,D)

<li>
FDs: A→C; C→B,D

</ul>
<li>
Start with set of candidates: attributes that imply and are not implied (not in any right hand side)

<ul>
<li>
{ {A} }

</ul>
<li>
Find cover of smallest candidate key

<ul>
<li>
{A} ⇒ {A,C} ⇒ {A,B,C,D}

</ul>
<li>
If does not contain all attributes, extend candidate with missing others and repeat.

<li>
edge case: if there are no attributes that aren't in any right hand side, then candidates is empty set { {} } and you extend with every attribute like { {A}, {B}, ...}

</ul>

<div id="Databases-Relational normal forms-Functional dependencies-Determinants"><h4 id="Determinants" class="header"><a href="#Databases-Relational normal forms-Functional dependencies-Determinants">Determinants</a></h4></div>
<p>
determinant: non-trivial, minimal functional dependency
</p>

<p>
{A1, ..., An} is determinant for {B1, ..., Bm} if:
</p>
<ul>
<li>
functional dependency A1, ..., An → B1, ..., Bm holds; and

<li>
left-hand side is minimal (if any Ai is removed, then it does not hold); and

<li>
it is non-trivial, i.e. {B1, ..., Bm} not subset of {A1, ..., An}

</ul>

<div id="Databases-Relational normal forms-Functional dependencies-Consequences of bad database design"><h4 id="Consequences of bad database design" class="header"><a href="#Databases-Relational normal forms-Functional dependencies-Consequences of bad database design">Consequences of bad database design</a></h4></div>
<p>
usually if table contains an functional dependency that's not implied by a key, it's a sign of bad database design.
</p>

<p>
leads to:
</p>
<ul>
<li>
redundant storage of certain facts

<ul>
<li>
wastes storage space

<li>
hard to ensure integrity when updating, as all redundant copies need to be updated, wasting time

<li>
requires additional constraints to guarantee integrity

</ul>
<li>
insert, update, deletion anomalies

<ul>
<li>
update: when a single value needs to be changed, multiple tuples need to be updated, taking longer and maybe getting out of sync

<li>
insertion: when unrelated concepts are stored together in a single table

<li>
deletion: e.g. when last course of instructor is deleted, their phone number is lost

</ul>
</ul>

<p>
problem is that general FDs are not supported by relational databases. so you have to transform them into key constraints (database normalisation).
</p>

<div id="Databases-Relational normal forms-Normal forms"><h3 id="Normal forms" class="header"><a href="#Databases-Relational normal forms-Normal forms">Normal forms</a></h3></div>
<p>
Normal form types:
</p>
<ul>
<li>
Third Normal Form (3NF): standard relational normal form used in practice

<li>
Boyce-Codd Normal Form (BCNF):

<ul>
<li>
a bit more restrictive, easier to define, better for intuition

<li>
BCNF requires that all functional dependencies are keys.

<li>
ensures that key constraints automatically satisfy all FDs, so no more constraints are needed

<li>
anomalies (update/insertion/deletion) don't occur

</ul>
</ul>

<p>
Normalisation algorithms can construct good relation schemas from attributes and functional dependencies. When an ER model is well designed, resulting derived relational tables will automatically be in BCNF.
</p>

<p>
First normal form (1NF):
</p>
<ul>
<li>
requires all table entries are atomic (not lists, sets, records, or relations)

<li>
all further normal forms assume that tables are in 1NF

</ul>

<div id="Databases-Relational normal forms-Normal forms-Boyce-Codd Normal Form (BCNF)"><h4 id="Boyce-Codd Normal Form (BCNF)" class="header"><a href="#Databases-Relational normal forms-Normal forms-Boyce-Codd Normal Form (BCNF)">Boyce-Codd Normal Form (BCNF)</a></h4></div>
<ul>
<li>
if all of its FDs are implied by its key constraints

<li>
in symbols:

<ul>
<li>
for every FD A1,...,An → B1,...,Bm of R, we have

<li>
either {B1,...,Bm} ⊆ {A1,...,An} (the FD is trivial)

<li>
or {A1,...,An} contains a key of R

</ul>
<li>
in short, if for every non-trivial functional dependency, left-hand side contains a key

</ul>
<blockquote>
<img src="img-databases/example-of-checking-bcnf.png" alt="Example of checking BCNF" />
</blockquote>

<div id="Databases-Relational normal forms-Normal forms-Boyce-Codd Normal Form (BCNF)-Splitting relations"><h5 id="Splitting relations" class="header"><a href="#Databases-Relational normal forms-Normal forms-Boyce-Codd Normal Form (BCNF)-Splitting relations">Splitting relations</a></h5></div>
<p>
If table R is not in BCNF, we can split it into two tables. You split based on violating FD.
</p>

<p>
Table decomposition:
</p>
<ul>
<li>
if FD A1,...,An → B1,...,Bm violates BCNF:

<ol>
<li>
create new relation S(A1,...,An,B1,...,Bm)

<li>
and remove B1,...,Bm from original relation R

</ol>
</ul>

<p>
Splitting has to be <span id="Databases-Relational normal forms-Normal forms-Boyce-Codd Normal Form (BCNF)-Splitting relations-lossless"></span><strong id="lossless">lossless</strong> so that you can reconstruct original relation by a join.
</p>

<p>
Decomposition theorem: split is guaranteed to be lossless if intersection of attributes of new tables is a key of at least one of them.
</p>

<p>
It's always possible to transform relation into BCNF by lossless splitting. The resulting schema can always represent all previously possible states, but it may be more general and allow states that do not exist in the old schema.
</p>

<p>
With computable columns, splitting the relation is not the right solution - instead, define a view with the computed column.
</p>

<p>
A good decomposition should guarantee preservation of FDs:
</p>
<ul>
<li>
and FD can refer only to attributes of a single relation

<li>
when splitting relation into two, there might be FDs that can't be expressed anymore (not preserved)

</ul>

<div id="Databases-Relational normal forms-Normal forms-Boyce-Codd Normal Form (BCNF)-Synthesis"><h5 id="Synthesis" class="header"><a href="#Databases-Relational normal forms-Normal forms-Boyce-Codd Normal Form (BCNF)-Synthesis">Synthesis</a></h5></div>
<p>
Determining canonical (minimal) set of FDs:
</p>
<ul>
<li>
given:

<ul>
<li>
R(A,B,C,D,E)

<li>
FDs: D→A; E→A,D; C,D→A; A,E→C; B→A,D,E

</ul>
<li>
Rewrite every FD as singular:

<ul>
<li>
D→A, E→A, E→D, C,D→A, A,E→C, B→A, B→D, B→E

</ul>
<li>
Minimise left hand side of every FD (aka is every FD minimal?)

<ul>
<li>
drop C from C,D→A because D→A

<li>
drop A from A,E→C because E→A

<li>
so: D→A, E→A, E→D, D→A, E→C, B→A, B→D, B→E

</ul>
<li>
Remove implied FDs (and trivial/duplicate) using lhs attributes (aka if we can determine rhs without the FD itself)

<ul>
<li>
D→A, E→D, E→C, B→E

</ul>
</ul>

<p>
BCNF synthesis (relation R, set of FDs for R):
</p>
<ol>
<li>
Determine canonical set of FDs

<ul>
<li>
e.g. D→A, E→D, E→C, B→E

</ul>
<li>
Maximise rhs of FDs

<ul>
<li>
{D}+ - D = {A}

<li>
\({E}_{-E}^+\) = {D,C,A}

<li>
\({B}_{-B}^+\) = {E,D,C,A}  ({B} is the minimal key in this case)

</ul>
<li>
Split on violating FDs. For each FD, remove the rhs from relations and add a new relation, with the lhs of that FD being the key.

</ol>

<div id="Databases-Relational normal forms-Normal forms-Third normal form (3NF)"><h4 id="Third normal form (3NF)" class="header"><a href="#Databases-Relational normal forms-Normal forms-Third normal form (3NF)">Third normal form (3NF)</a></h4></div>
<ul>
<li>
relation is in 3NF if for every non-trivial functional dependency:

<ul>
<li>
left-hand side contains a key

<li>
or right-hand side is attribute of minimal key

</ul>
</ul>

<p>
retains all FDs, so more popular than BCNF. If we leave table in 3NF, we have non-key constraints - the FDs that are not implied by keys.
</p>

<div id="Databases-Relational normal forms-Normal forms-Third normal form (3NF)-Synthesis"><h5 id="Synthesis" class="header"><a href="#Databases-Relational normal forms-Normal forms-Third normal form (3NF)-Synthesis">Synthesis</a></h5></div>
<p>
Produces lossless decomposition of relation into 3NF that preserves FDs.
</p>

<ol>
<li>
Determine canonical set of FDs

<ul>
<li>
e.g. D→A, E→D, E→C, B→E

</ul>
<li>
Merge FDs with same lhs and create relations from them

<ul>
<li>
R1(<u>D</u>, A)

<li>
R2(<u>E</u>,C,D)

<li>
R3(<u>B</u>,E)

</ul>
<li>
Check if any of relations has key of original relation. If not, create a new relation with attributes of the minimal key.

<ul>
<li>
In this case, R(A,<u>B</u>,C,D,E); R3 has <u>B</u>, so don't need to do anything.

</ul>
<li>
For all pairs of created relations: are they contained in another relation? If yes, remove.

</ol>

<div id="Databases-Relational normal forms-MVD &amp; 4NF"><h3 id="MVD &amp; 4NF" class="header"><a href="#Databases-Relational normal forms-MVD &amp; 4NF">MVD &amp; 4NF</a></h3></div>
<div id="Databases-Relational normal forms-MVD &amp; 4NF-Multivalued dependencies (MVDs)"><h4 id="Multivalued dependencies (MVDs)" class="header"><a href="#Databases-Relational normal forms-MVD &amp; 4NF-Multivalued dependencies (MVDs)">Multivalued dependencies (MVDs)</a></h4></div>
<p>
Constraints that give a necessary and sufficient condition for lossless decomposition. They lead to fourth normal form (4NF).
</p>

<p>
Multivalued dependency <code>NAME ⤅ PROG_LANG</code> means that set of vales in in column PROG_LANG associated with every NAME is independent of all other columns. i.e. there's an embedded function from NAME to sets of PROG_LANG
</p>

<p>
The MVD holds if, whenever two tuples agree on NAME, one can exchange their PROG_LANG values and the resulting tuples are in the same table.
</p>

<p>
MVDs always come in pairs. For relation R(A1,...,An, B1,...,Bm, C1,...,Ck) these multivalued dependencies are equivalent:
</p>
<ul>
<li>
A1,...,An ⤅ B1,...,Bm

<li>
A1,...,An ⤅ C1,...,Ck

</ul>

<p>
Every FD is also a MVD.
</p>

<div id="Databases-Relational normal forms-MVD &amp; 4NF-Fourth Normal Form (4NF)"><h4 id="Fourth Normal Form (4NF)" class="header"><a href="#Databases-Relational normal forms-MVD &amp; 4NF-Fourth Normal Form (4NF)">Fourth Normal Form (4NF)</a></h4></div>
<p>
A relation is in in 4NF if every MVD A1,...,An ⤅ B1,...,Bm is either trivial, or implied by a key.
</p>

<p>
If a relation is in 4NF, it's also automatically in BCNF.
</p>

<div id="Databases-Relational normal forms-Normal forms &amp; ER design"><h3 id="Normal forms &amp; ER design" class="header"><a href="#Databases-Relational normal forms-Normal forms &amp; ER design">Normal forms &amp; ER design</a></h3></div>
<p>
If a 'good' ER schema is transformed into the relational model, the result will satisfy all normal forms (4NF, BCNF, 3NF). If a normal form is violated, there's a flaw in the input ER schema.
</p>

<p>
In the ER model, the entity has to be split in case of a violation.
</p>

<p>
Violations of BCNF can also be due to wrong placement of an attribute.
</p>

<p>
If an attribute of a ternary relationship only depends on two of the entities, it's a BCNF violation.
</p>

<p>
Why normalize?
</p>
<ul>
<li>
Avoid redundancy

<li>
Store separate facts separately

<li>
Transform general integrity constraints into keys (DBMS constraints)

</ul>

<div id="Databases-Relational normal forms-Denormalization"><h3 id="Denormalization" class="header"><a href="#Databases-Relational normal forms-Denormalization">Denormalization</a></h3></div>
<p>
The process of adding redundant columns to the database to improve performance.
</p>

<p>
This leads to the reintroduction of (some) anomalies, but you avoid huge amounts of joins.
</p>

<div id="Databases-Transactions"><h2 id="Transactions" class="header"><a href="#Databases-Transactions">Transactions</a></h2></div>
<p>
transaction: a sequence of actions we want to perform on a database
</p>

<p>
should be atomic: either run fully, or not at all.
this avoids concurrency problems like:
</p>
<ul>
<li>
losing effects of one transaction due to uncontrolled overwrite by another ('lost update anomaly')

<li>
transaction reads partial result of another transaction ('inconsistent read anomaly')

<li>
transaction reads changes made by another transaction before they are rolled back ('dirty read anomaly')

<li>
transaction reads value which is afterwards changed by another transaction ('unrepeatable read anomaly')

</ul>

<p>
For this, we need to get some ACID:
</p>
<ul>
<li>
Atomicity: transaction executes fully or not at all (commit or abort)

<li>
Consistency: transactions always leave database in consistent state, where all defined integrity constraints hold

<li>
Isolation: multiple users can modify database at the same time without seeing partial actions

<li>
Durability: when transaction is committed successfully, the data is persistent, regardless of crashes

</ul>

<p>
transaction: a list of actions
</p>
<ul>
<li>
reads - R(O)

<li>
writes - W(O)

<li>
end with Commit or Abort

<li>
e.g.: T₁: R(V)&lt; R(Y), W(V), W(C), Commit

</ul>

<div id="Databases-Transactions-Schedules"><h3 id="Schedules" class="header"><a href="#Databases-Transactions-Schedules">Schedules</a></h3></div>
<p>
scheduler decides execution order of concurrent database access
</p>

<p>
schedule is list of actions from set of transactions ('plan on how to execute transactions'). order in which 2 actions of transaction T appear in schedule must be same as order in T.
</p>

<div id="Databases-Transactions-Serializability"><h3 id="Serializability" class="header"><a href="#Databases-Transactions-Serializability">Serializability</a></h3></div>
<p>
serial schedule: if actions of different transactions are executed one after another (e.g. all of T2, then all of T1)
</p>

<p>
serializable schedule: if its effect on database is same as that of some serial schedule
</p>

<p>
actions in schedule conflict if they
</p>
<ul>
<li>
are from different transactions

<li>
and involve same data item

<li>
and one action is write

</ul>

<p>
conflicts may cause schedule to not be serializable
</p>

<p>
conflict types:
</p>
<ul>
<li>
write read (WR) - T₁ writes Y, then T₂ reads Y

<li>
read write (RW) - T₁ reads Y, then T₂ writes Y

<li>
write write (WW) - T₁ writes Y, then T₂ writes Y

</ul>

<p>
we can swap actions of different transactions if actions are non-conflicting.
</p>

<p>
conflict equivalent schedules: if they can be transformed into each other by swapping non-conflicting, adjacent transactions.
</p>

<p>
conflict-serializable: if conflict equivalent to some serial schedule
</p>

<p>
check it with a precedence graph:
</p>
<ul>
<li>
graph has node for each transaction

<li>
edge from T₁ to T₂ if conflicting action between T₁ and T₂ (with T₁ first)

<li>
conflict-serializable iff no cycle in the graph

<li>
if no cycles, serial schedule is a topological sort of precedence graph

</ul>

<div id="Databases-Transactions-Runtime serializability strategies"><h3 id="Runtime serializability strategies" class="header"><a href="#Databases-Transactions-Runtime serializability strategies">Runtime serializability strategies</a></h3></div>
<p>
serializability during runtime: system doesn't know which transactions will run, and which items they'll access
</p>

<p>
strategies:
</p>
<ul>
<li>
Pessimistic: lock-based, timestamp based

<li>
Optimistic: read-set/write-set tracking, validation before commit

<li>
Multi-version techniques: eliminate concurrency control overhead for read-only queries

</ul>

<div id="Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking"><h4 id="Pessimistic: lock-based, two phase locking" class="header"><a href="#Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking">Pessimistic: lock-based, two phase locking</a></h4></div>
<p>
transactions must lock objects before using them
</p>

<p>
types:
</p>
<ul>
<li>
shared lock (S-lock): acquired on Y before <em>reading</em> Y, many transactions can hold a shared lock on Y

<li>
exclusive lock (X-lock): acquired on Y before <em>writing</em> Y. transaction can hold exclusive lock on Y if no other transaction holds a lock on Y.

</ul>

<p>
2 phase locking protocol:
</p>
<ul>
<li>
each transaction must get:

<ul>
<li>
S-lock on object before reading it

<li>
X-lock on object before writing it

</ul>
<li>
transaction can't get new locks once it releases any lock

<li>
any schedule that conforms to 2PL is conflict-serializable

</ul>

<div id="Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Deadlock handling"><h5 id="Deadlock handling" class="header"><a href="#Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Deadlock handling">Deadlock handling</a></h5></div>
<p>
2 PL has the risk of deadlocks where both transactions wait for each other indefinitely. need to detect deadlock.
</p>

<p>
detection with Wait-for-Graphs
</p>
<ul>
<li>
system maintains wait-for-graph, where nodes are transactions and edges A→B mean A is waiting for B to release lock

<li>
system periodically checks for graph cycles

<li>
if cycle detected, you abort a transaction

<li>
selecting the victim is a challenge:

<ul>
<li>
if you abort a young one, there will be starvation

<li>
if you abort an old one, you'll be throwing away what you invested in it

<li>
phrasing, dude.

</ul>
</ul>

<p>
detection with timeout
</p>
<ul>
<li>
let transactions block on a lock request for a limited time

<li>
after timeout, assume deadlock and abort T

</ul>

<div id="Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Cascading rollbacks"><h5 id="Cascading rollbacks" class="header"><a href="#Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Cascading rollbacks">Cascading rollbacks</a></h5></div>
<p>
cascadeless schedule
</p>
<ul>
<li>
delay reads, only read value produced by already committed transactions

<li>
so if a value is required, wait for the commit

<li>
no dirty reads, so abort doesn't cascade

</ul>

<p>
recoverable schedule:
</p>
<ul>
<li>
delay commit - if T2 reads value written by T1, commit of T2 has to wait until after commit of T1

</ul>

<p>
schedules should always be recoverable. all cascadeless schedules are recoverable.
</p>

<div id="Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Strict 2 phase locking"><h5 id="Strict 2 phase locking" class="header"><a href="#Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Strict 2 phase locking">Strict 2 phase locking</a></h5></div>
<p>
same as 2PL, but a transaction releases all locks only when it's completed (commit/rollback).
it's cascadeless, but still has deadlocks.
</p>

<div id="Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Preclaiming 2 phase locking"><h5 id="Preclaiming 2 phase locking" class="header"><a href="#Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Preclaiming 2 phase locking">Preclaiming 2 phase locking</a></h5></div>
<p>
all needed locks are declared at start of transaction.
therefore, no deadlocks.
however, not applicable in multi-query transactions (where queries might depend on results of previous queries)
</p>

<div id="Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Granularity of locking"><h5 id="Granularity of locking" class="header"><a href="#Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Granularity of locking">Granularity of locking</a></h5></div>
<p>
there's a tradeoff.
the more specific your locking is (database, vs table, vs row level), the higher concurrency you have, and the higher overhead
</p>

<p>
multi-granularity locking - decide granularity of locks held for each transaction depending on characteristics of transaction
</p>

<p>
intention locks (do not conflict with each other):
</p>
<ul>
<li>
intention share (IS)

<li>
intention exclusive (IX)

</ul>

<p>
an intention lock on coarser level of granularity means there is S/X lock on finer level of granularity.
</p>

<p>
before a granule <em>g can</em> be locked in S/X mode, the transaction has to obtain an IS/IX lock on all coarser granularities containing <em>g</em>
</p>

<p>
after all intention locks are granted, transaction can lock <em>g</em> in the announced mode
</p>

<p>
levels of granularity: database → table → row
</p>

<div id="Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Optimising performance"><h5 id="Optimising performance" class="header"><a href="#Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Optimising performance">Optimising performance</a></h5></div>
<p>
for each query in log:
</p>
<ul>
<li>
analyse average time and variance for this type of query

<ul>
<li>
if long delays or frequently aborts, might be contention

</ul>
<li>
read only or updating query?

<ul>
<li>
compute read-sets, write-sets

<li>
will it require row/table locks? shared/exclusive?

</ul>
</ul>

<p>
How do read- and write-sets of queries intersect? What is chance of conflicts?
</p>

<p>
When you understand the query workload, you can:
</p>
<ul>
<li>
rewrite queries for smaller read- and write-sets

<li>
change scheduling of queries to reduce contention

<li>
use different isolation level for queries

</ul>

<div id="Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Isolation levels"><h5 id="Isolation levels" class="header"><a href="#Databases-Transactions-Runtime serializability strategies-Pessimistic: lock-based, two phase locking-Isolation levels">Isolation levels</a></h5></div>
<p>
some degree of inconsistency may be acceptable to get increased concurrency &amp; performance
</p>

<p>
SQL-92 levels:
</p>
<ul>
<li>
<code>read uncommitted</code>: only write locks acquired, any row read can be concurrently changed by other transactions

<li>
<code>read committed</code>: read locks held for as long as application cursor sits on a current row, write locks as usual

<li>
<code>repeatable read</code>: strict 2PL, a transaction may read phantom rows if it runs an aggregation query twice

<li>
<code>serializable</code>: strict 2PL, multi-granularity locking. no phantom rows.

</ul>

<p>
<img src="img-databases/sql-92-isolation-levels.png" alt="SQL-92 isolation levels" />
</p>

<p>
phantom row problem: T1 locks all rows, but T2 inserts new row that isn't locked.
</p>

<p>
solutions:
</p>
<ul>
<li>
multi-granularity locking (locking the table)

<li>
declarative locking - key-range or predicate locking

</ul>

<p>
many applications don't need full serializability, selecting a weaker but acceptable isolation level is part of database tuning.
</p>

<div id="Databases-Transactions-Runtime serializability strategies-Optimistic concurrency control"><h4 id="Optimistic concurrency control" class="header"><a href="#Databases-Transactions-Runtime serializability strategies-Optimistic concurrency control">Optimistic concurrency control</a></h4></div>
<p>
hope for the best, only check that no conflicts happened when committing. this saves locking overhead.
</p>

<p>
three phases:
</p>
<ol>
<li>
Read phase: execute transaction, but don't write data to disk. collect updates in transaction's private workspace

<li>
Validation phase: when transaction wants to commit, DBMS test whether execution correct, and abort if needed.

<li>
Write phase: transfer data from private workspace into database.

</ol>

<p>
Phases 2, 3 have to be in non-interruptible critical section (val-write phase).
</p>

<div id="Databases-Transactions-Runtime serializability strategies-Optimistic concurrency control-Validation"><h5 id="Validation" class="header"><a href="#Databases-Transactions-Runtime serializability strategies-Optimistic concurrency control-Validation">Validation</a></h5></div>
<p>
typically implemented by maintaining:
</p>
<ul>
<li>
read set RS(Tk) - attributes read by Tk

<li>
write set Ws(Tk) - attributes written by Tk

</ul>

<p>
Backward-oriented optimistic concurrency control (BOCC)
</p>
<ul>
<li>
on commit, compare Tk against all <em>committed</em> transactions Ti

<li>
succeeds if

<ul>
<li>
Ti committed before Tk started

<li>
or Rs(Tk) ∩ WS(Ti) = Ø

</ul>
</ul>

<p>
Forward-oriented optimistic concurrency control (FOCC)
</p>
<ul>
<li>
on commit, compare Tk against all <em>running</em> transactions Ti

<li>
succeeds if

<ul>
<li>
Ws(Tk) ∩ RS(Ti) = Ø

</ul>
</ul>

<div id="Databases-Transactions-Runtime serializability strategies-Optimistic concurrency control-Multiversion concurrency control"><h5 id="Multiversion concurrency control" class="header"><a href="#Databases-Transactions-Runtime serializability strategies-Optimistic concurrency control-Multiversion concurrency control">Multiversion concurrency control</a></h5></div>
<p>
with old object versions around, read-only transactions never need to be blocked
</p>
<ul>
<li>
might see outdated but consistent version of data

<li>
like everything in query happened the moment it started

</ul>

<p>
issues:
</p>
<ul>
<li>
versioning requires space and management overhead

<li>
update transactions still need concurrency control

</ul>

<p>
snapshot isolation: 
</p>
<ul>
<li>
each transaction sees consistent snapshot of database corresponding to state at moment it started

<li>
read-only transactions don't have to lock anything

<li>
transactions conflict if write to same object

<ul>
<li>
pessimistic concurrency control - only writes are locked

<li>
optimistic concurrency control - only write-sets interesting

</ul>
<li>
does not guarantee serializability

<li>
avoids dirty read, unrepeatable read, phantom rows

<li>
introduces write skew, with complex assertions involving multiple tuples

</ul>

    </div>
</body>
</html>
