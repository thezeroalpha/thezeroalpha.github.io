<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
    <script type="text/javascript" async src="https://cdn.jsdelivr.net/gh/mathjax/MathJax@2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css">
    <link rel="Stylesheet" type="text/css" href="style.css" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        document.querySelectorAll('pre.code').forEach(function(item) {
          hljs.highlightBlock(item)
        })
      });
    </script>
    <title>Intro to Cryptography</title>
</head>
<body>
<style type="text/css">
nav a {
    text-align: left;
}
nav #name {
    text-align: right;
    float: right;
    font-style: italic;
}
</style>
    <nav>
    <a href="">Home</a>
    <a href="index.html">Index</a>
    <span id="name">Alex Balgavy</span>
    </nav>
    <hr>
    <div class="content">
    
<div id="Introduction to Cryptography"><h1 id="Introduction to Cryptography" class="header"><a href="#Introduction to Cryptography">Introduction to Cryptography</a></h1></div>
<div id="Introduction to Cryptography-Definitions"><h2 id="Definitions" class="header"><a href="#Introduction to Cryptography-Definitions">Definitions</a></h2></div>
<p>
Symmetric cryptography:
</p>
<ul>
<li>
text → ciphertext with public key

<li>
ciphertext → text with private key

</ul>

<p>
Basic terminology:
</p>
<ul>
<li>
plain text: text to be encoded.

<ul>
<li>
𝓟 = finite set of possible plaintexts

<li>
convention: lowercase

</ul>
<li>
ciphertext: the encoded text

<ul>
<li>
𝓒 = finite set of ciphertexts

<li>
convention: uppercase

</ul>
<li>
cryptosystem consists of a 5-tuple (𝓟, 𝓒, 𝓚, 𝓔, 𝓓)

<ul>
<li>
𝓚 = finite set of keys

<li>
encryption 𝓔 = { ek : 𝓟  → 𝓒 | k ∈ 𝓚 }

<li>
decryption 𝓓 = { dk : 𝓒 → 𝓟 | k ∈ 𝓚 }

<li>
st ∀x ∈ 𝓟, dk(ek(x)) = x

</ul>
<li>
ek is one-to-one function (injective)

<li>
dk is onto (surjective)

<li>
|𝓟 | ≤ |𝓒 |

<li>
if |𝓟 |= |𝓒| then both ek and dk are one-to-one and onto (bijective)

<li>
dk = ek⁻¹, ek = dk⁻¹, dk × ek = idp

<li>
if ek = 𝓟 → 𝓟 then ek is a permutation (like Shift cipher)

</ul>

<p>
Also, each letter has a number associated with it, starting at 0.
</p>

<div id="Introduction to Cryptography-Modular arithmetic"><h2 id="Modular arithmetic" class="header"><a href="#Introduction to Cryptography-Modular arithmetic">Modular arithmetic</a></h2></div>
<p>
Z = set of all integers, Z&gt;0 = all positive integers
</p>

<p>
a ≡ b mod m if m|a-b. in English, a is equivalent to b, mod m, if m divides a-b.
</p>

<p>
For example, \(-1 \mod 26 = 25\) because \(-1 = (26)(-1) + 25\).
Easy way to calculate that is to do <code>26-1</code>.
</p>

<p>
We say a' is inverse of a if \(a × a' = 1 = a' × a\) where \(a, a' \in Zm\).
So m|aa'-1 in Z.
</p>

<p>
Inverse is well defined, any two inverses are equal to each other.
Inverse is unique.
</p>

<p>
If a,b ∈ Z, then exists s,t ∈ Z such that as+bt = gcd(a,b).
</p>

<p>
If a ∈ Zm then a⁻¹ exists iff gcd(a,m) = 1.
</p>

<div id="Introduction to Cryptography-Multiplicative inversion (Zm matrix n×n)"><h2 id="Multiplicative inversion (Zm matrix n×n)" class="header"><a href="#Introduction to Cryptography-Multiplicative inversion (Zm matrix n×n)">Multiplicative inversion (Zm matrix n×n)</a></h2></div>
<p>
If A is n×n matrix in R, then A has inverse if exists n×n matrix A' st A∙A' = A'∙A = In
</p>

<p>
A has inverse iff detA ≠ 0.
</p>

<p>
Compute inverse by using row reduction operations.
</p>

<p>
If A is n×n matrix with entries in Zm then def of A⁻¹ is the same.
If A⁻¹ exists then it is unique.
</p>

<p>
detA has inverse in Zm iff \(gcd(detA, m) = 1\).
</p>

<p>
Cofactor matrix: \(C = ((-1)^{i+j} \det{A_{ij}})) \quad i=1..n, j=1..n\)
</p>

<p>
Adjoint matrix: the transposed cofactor matrix.
</p>

<p>
For n ≥ 1, \(A∙adjA = (detA) In = adjA∙A\).
</p>

<div id="Introduction to Cryptography-Shift Cipher"><h2 id="Shift Cipher" class="header"><a href="#Introduction to Cryptography-Shift Cipher">Shift Cipher</a></h2></div>
<p>
Definition:
</p>
<ul>
<li>
𝓟 = 𝓒 = 𝓚 = Z₂₆

<li>
𝓔 = { ek : Z₂₆ → Z₂₆ | k ∈ Z₂₆ }

<li>
𝓓 = { dk : Z₂₆ → Z₂₆ | k ∈ Z₂₆ }

<li>
ek(x) = x+k

<li>
dk(x) = ek⁻¹(x) = y-k

</ul>

<p>
Check if it's good:
</p>

\begin{align}
dk(ek(x)) = ek(x) - k \\
         &amp;= x+k-k \\
         &amp;= x \\
\end{align}

<p>
Cryptanalysis
</p>
<ul>
<li>
To find the key, you can make a table with options for \(-k\) on the left.

<li>
Then you can perform an exhaustive search.

</ul>

<div id="Introduction to Cryptography-Substitution cipher"><h2 id="Substitution cipher" class="header"><a href="#Introduction to Cryptography-Substitution cipher">Substitution cipher</a></h2></div>
<p>
Definition
</p>
<ul>
<li>
𝓟, 𝓒 two finite sets st |𝓟| = |𝓒|

<li>
𝓚 = { π : 𝓟 → 𝓒 | π bijection }

<li>
eπ = π

<li>
dπ = eπ⁻¹ = π⁻¹

</ul>

<p>
If |𝓟| = n = |𝓒| then |𝓚| = n!.
π is permutation.
</p>

<p>
Two possible types:
</p>
<ul>
<li>
monoalphabetic: 𝓟 = Σ (Σ: alphabet)

<li>
polyalphabetic: 𝓟 = Σ^𝓵

</ul>

<div id="Introduction to Cryptography-Affine cipher"><h2 id="Affine cipher" class="header"><a href="#Introduction to Cryptography-Affine cipher">Affine cipher</a></h2></div>
<p>
Definition:
</p>
<ul>
<li>
𝓟 = 𝓒 = Zm, m &gt; 0

<li>
𝓚 = U(Zm) × Zm

<li>
e(a,b)(x) = ax+b

<li>
d(a,b)(y) = e(a,b)⁻¹ = a⁻¹ × (y-b)

</ul>

<p>
This becomes the shift cipher if a = 1.
</p>

<div id="Introduction to Cryptography-Vigenere cipher"><h2 id="Vigenere cipher" class="header"><a href="#Introduction to Cryptography-Vigenere cipher">Vigenere cipher</a></h2></div>
<p>
Definition:
</p>
<ul>
<li>
𝓟 = 𝓒 = 𝓚 = Σ^𝓵

<li>
Σ = Z₂₆

<li>
𝓚 = (k1, .., k𝓵)

</ul>

<div id="Introduction to Cryptography-Hill cipher"><h2 id="Hill cipher" class="header"><a href="#Introduction to Cryptography-Hill cipher">Hill cipher</a></h2></div>
<p>
A block cipher, where you cut text into parts of equal length.
</p>

<p>
Definition:
</p>
<ul>
<li>
𝓟 = Zm length 𝓵 = 𝓒

<li>
𝓚 = { k | k is invertible 𝓵×𝓵 matrix with entries in Zm }

<li>
ek(x1...x𝓵) = (x1...x𝓵)k = (y...y𝓵)

<ul>
<li>
right matrix multiplication!!

</ul>
<li>
dk(y) = yk⁻¹

</ul>

<div id="Introduction to Cryptography-Affine linear cipher"><h2 id="Affine linear cipher" class="header"><a href="#Introduction to Cryptography-Affine linear cipher">Affine linear cipher</a></h2></div>
<p>
Definition:
</p>
<ul>
<li>
𝓟 = Zm^𝓵 = 𝓒

<li>
𝓚 = { (A,b) | A invertible 𝓵×𝓵 matrix, b ∈ Zm^𝓵 }

<li>
ek(x) = xA+b

<li>
dk(y) = (y-b)A⁻¹

</ul>

<div id="Introduction to Cryptography-Permutation cipher"><h2 id="Permutation cipher" class="header"><a href="#Introduction to Cryptography-Permutation cipher">Permutation cipher</a></h2></div>
<p>
Definition:
</p>
<ul>
<li>
𝓟 = (Zm)^𝓵 = 𝓒

<li>
K = { π permutation of 1,2,...𝓵 }

<li>
ek(x1...x𝓵) = (x_π(1)...x_π(𝓵))

<li>
dk(y1...y𝓵) = (y_π⁻¹(1)...y_π⁻¹(𝓵))

</ul>

<p>
A particular case of the Hill cipher using 𝓵×𝓵 matrix with a shuffled I𝓵.
</p>

<div id="Introduction to Cryptography-Stream ciphers"><h2 id="Stream ciphers" class="header"><a href="#Introduction to Cryptography-Stream ciphers">Stream ciphers</a></h2></div>
<p>
Like block ciphers, but different key for every block.
Key is a stream key, either constructed using an initial key + a rule, or with key together with plaintext.
key may depend on the text.
</p>

<div id="Introduction to Cryptography-Stream ciphers-Synchronous stream ciphers"><h3 id="Synchronous stream ciphers" class="header"><a href="#Introduction to Cryptography-Stream ciphers-Synchronous stream ciphers">Synchronous stream ciphers</a></h3></div>
<ul>
<li>
keystream can be obtained from initial key

<li>
Definition:

<ul>
<li>
𝓟 finite set of plaintexts

<li>
𝓒 finite set of ciphertexts

<li>
𝓚 finite set of possible keys

<li>
𝓛 finite set of keystream alphabet

<li>
𝓔 = { ez : 𝓟 → 𝓒 | z ∈ 𝓛 }

<li>
𝓓 = { dz : 𝓒 → 𝓟 | z ∈ 𝓛 }

<li>
ez(x) = x+z

<li>
dz(y) = y+z

<li>
generating key stream function: g(k) = z1, z2...zk...

</ul>
</ul>

<div id="Introduction to Cryptography-Stream ciphers-Synchronous stream ciphers-Linear recurrence stream cipher"><h4 id="Linear recurrence stream cipher" class="header"><a href="#Introduction to Cryptography-Stream ciphers-Synchronous stream ciphers-Linear recurrence stream cipher">Linear recurrence stream cipher</a></h4></div>
<p>
Everything is Z₂.
Max period is 2^𝓵 -1.
Z_𝓵+i = c1 zi + c2 z_i+1 + ... + c𝓵 z_i+𝓵-1.
</p>


<div id="Introduction to Cryptography-Stream ciphers-Non-synchronous stream ciphers:"><h3 id="Non-synchronous stream ciphers:" class="header"><a href="#Introduction to Cryptography-Stream ciphers-Non-synchronous stream ciphers:">Non-synchronous stream ciphers:</a></h3></div>
<ul>
<li>
key depends on initial key and plaintext

</ul>

<div id="Introduction to Cryptography-Stream ciphers-Non-synchronous stream ciphers:-Autokey cipher"><h4 id="Autokey cipher" class="header"><a href="#Introduction to Cryptography-Stream ciphers-Non-synchronous stream ciphers:-Autokey cipher">Autokey cipher</a></h4></div>
<p>
Only use the keyword on the first chunk.
Then use plaintext for rest.
</p>

<p>
functions:
</p>
<ul>
<li>
ez(x) = x+z

<li>
dz(y) = y-z

</ul>


<p>
Autokey encrypts different plaintexts using different key streams.
But if there's noise on the channel, shit gets fucked.
</p>

    </div>
</body>
</html>
