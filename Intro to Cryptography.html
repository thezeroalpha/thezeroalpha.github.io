<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
    <script type="text/javascript" async src="https://cdn.jsdelivr.net/gh/mathjax/MathJax@2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css">
    <link rel="Stylesheet" type="text/css" href="style.css" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        document.querySelectorAll('pre.code').forEach(function(item) {
          hljs.highlightBlock(item)
        })
      });
    </script>
    <title>Intro to Cryptography</title>
</head>
<body>
<style type="text/css">
nav a {
    text-align: left;
}
nav #name {
    text-align: right;
    float: right;
    font-style: italic;
}
</style>
    <nav>
    <a href="">Home</a>
    <a href="index.html">Index</a>
    <span id="name">Alex Balgavy</span>
    </nav>
    <hr>
    <div class="content">
    
<div id="Introduction to Cryptography"><h1 id="Introduction to Cryptography" class="header"><a href="#Introduction to Cryptography">Introduction to Cryptography</a></h1></div>
<div id="Introduction to Cryptography-Definitions"><h2 id="Definitions" class="header"><a href="#Introduction to Cryptography-Definitions">Definitions</a></h2></div>
<p>
Symmetric cryptography:
</p>
<ul>
<li>
text â†’ ciphertext with public key

<li>
ciphertext â†’ text with private key

</ul>

<p>
Basic terminology:
</p>
<ul>
<li>
plain text: text to be encoded.

<ul>
<li>
ğ“Ÿ = finite set of possible plaintexts

<li>
convention: lowercase

</ul>
<li>
ciphertext: the encoded text

<ul>
<li>
ğ“’ = finite set of ciphertexts

<li>
convention: uppercase

</ul>
<li>
cryptosystem consists of a 5-tuple (ğ“Ÿ, ğ“’, ğ“š, ğ“”, ğ““)

<ul>
<li>
ğ“š = finite set of keys

<li>
encryption ğ“” = { ek : ğ“Ÿ  â†’ ğ“’ | k âˆˆ ğ“š }

<li>
decryption ğ““ = { dk : ğ“’ â†’ ğ“Ÿ | k âˆˆ ğ“š }

<li>
st âˆ€x âˆˆ ğ“Ÿ, dk(ek(x)) = x

</ul>
<li>
ek is one-to-one function (injective)

<li>
dk is onto (surjective)

<li>
|ğ“Ÿ | â‰¤ |ğ“’ |

<li>
if |ğ“Ÿ |= |ğ“’| then both ek and dk are one-to-one and onto (bijective)

<li>
dk = ekâ»Â¹, ek = dkâ»Â¹, dk Ã— ek = idp

<li>
if ek = ğ“Ÿ â†’ ğ“Ÿ then ek is a permutation (like Shift cipher)

</ul>

<p>
Also, each letter has a number associated with it, starting at 0.
</p>

<div id="Introduction to Cryptography-Modular arithmetic"><h2 id="Modular arithmetic" class="header"><a href="#Introduction to Cryptography-Modular arithmetic">Modular arithmetic</a></h2></div>
<p>
Z = set of all integers, Z&gt;0 = all positive integers
</p>

<p>
a â‰¡ b mod m if m|a-b. in English, a is equivalent to b, mod m, if m divides a-b.
</p>

<p>
For example, \(-1 \mod 26 = 25\) because \(-1 = (26)(-1) + 25\).
Easy way to calculate that is to do <code>26-1</code>.
</p>

<p>
We say a' is inverse of a if \(a Ã— a' = 1 = a' Ã— a\) where \(a, a' \in Zm\).
So m|aa'-1 in Z.
</p>

<p>
Inverse is well defined, any two inverses are equal to each other.
Inverse is unique.
</p>

<p>
If a,b âˆˆ Z, then exists s,t âˆˆ Z such that as+bt = gcd(a,b).
</p>

<p>
If a âˆˆ Zm then aâ»Â¹ exists iff gcd(a,m) = 1.
</p>

<div id="Introduction to Cryptography-Multiplicative inversion (Zm matrix nÃ—n)"><h2 id="Multiplicative inversion (Zm matrix nÃ—n)" class="header"><a href="#Introduction to Cryptography-Multiplicative inversion (Zm matrix nÃ—n)">Multiplicative inversion (Zm matrix nÃ—n)</a></h2></div>
<p>
If A is nÃ—n matrix in R, then A has inverse if exists nÃ—n matrix A' st Aâˆ™A' = A'âˆ™A = In
</p>

<p>
A has inverse iff detA â‰  0.
</p>

<p>
Compute inverse by using row reduction operations.
</p>

<p>
If A is nÃ—n matrix with entries in Zm then def of Aâ»Â¹ is the same.
If Aâ»Â¹ exists then it is unique.
</p>

<p>
detA has inverse in Zm iff \(gcd(detA, m) = 1\).
</p>

<p>
Cofactor matrix: \(C = ((-1)^{i+j} \det{A_{ij}})) \quad i=1..n, j=1..n\)
</p>

<p>
Adjoint matrix: the transposed cofactor matrix.
</p>

<p>
For n â‰¥ 1, \(Aâˆ™adjA = (detA) In = adjAâˆ™A\).
</p>

<div id="Introduction to Cryptography-Shift Cipher"><h2 id="Shift Cipher" class="header"><a href="#Introduction to Cryptography-Shift Cipher">Shift Cipher</a></h2></div>
<p>
Definition:
</p>
<ul>
<li>
ğ“Ÿ = ğ“’ = ğ“š = Zâ‚‚â‚†

<li>
ğ“” = { ek : Zâ‚‚â‚† â†’ Zâ‚‚â‚† | k âˆˆ Zâ‚‚â‚† }

<li>
ğ““ = { dk : Zâ‚‚â‚† â†’ Zâ‚‚â‚† | k âˆˆ Zâ‚‚â‚† }

<li>
ek(x) = x+k

<li>
dk(x) = ekâ»Â¹(x) = y-k

</ul>

<p>
Check if it's good:
</p>

\begin{align}
dk(ek(x)) = ek(x) - k \\
         &amp;= x+k-k \\
         &amp;= x \\
\end{align}

<p>
Cryptanalysis
</p>
<ul>
<li>
To find the key, you can make a table with options for \(-k\) on the left.

<li>
Then you can perform an exhaustive search.

</ul>

<div id="Introduction to Cryptography-Substitution cipher"><h2 id="Substitution cipher" class="header"><a href="#Introduction to Cryptography-Substitution cipher">Substitution cipher</a></h2></div>
<p>
Definition
</p>
<ul>
<li>
ğ“Ÿ, ğ“’ two finite sets st |ğ“Ÿ| = |ğ“’|

<li>
ğ“š = { Ï€ : ğ“Ÿ â†’ ğ“’ | Ï€ bijection }

<li>
eÏ€ = Ï€

<li>
dÏ€ = eÏ€â»Â¹ = Ï€â»Â¹

</ul>

<p>
If |ğ“Ÿ| = n = |ğ“’| then |ğ“š| = n!.
Ï€ is permutation.
</p>

<p>
Two possible types:
</p>
<ul>
<li>
monoalphabetic: ğ“Ÿ = Î£ (Î£: alphabet)

<li>
polyalphabetic: ğ“Ÿ = Î£^ğ“µ

</ul>

<div id="Introduction to Cryptography-Affine cipher"><h2 id="Affine cipher" class="header"><a href="#Introduction to Cryptography-Affine cipher">Affine cipher</a></h2></div>
<p>
Definition:
</p>
<ul>
<li>
ğ“Ÿ = ğ“’ = Zm, m &gt; 0

<li>
ğ“š = U(Zm) Ã— Zm

<li>
e(a,b)(x) = ax+b

<li>
d(a,b)(y) = e(a,b)â»Â¹ = aâ»Â¹ Ã— (y-b)

</ul>

<p>
This becomes the shift cipher if a = 1.
</p>

<div id="Introduction to Cryptography-Vigenere cipher"><h2 id="Vigenere cipher" class="header"><a href="#Introduction to Cryptography-Vigenere cipher">Vigenere cipher</a></h2></div>
<p>
Definition:
</p>
<ul>
<li>
ğ“Ÿ = ğ“’ = ğ“š = Î£^ğ“µ

<li>
Î£ = Zâ‚‚â‚†

<li>
ğ“š = (k1, .., kğ“µ)

</ul>

<div id="Introduction to Cryptography-Hill cipher"><h2 id="Hill cipher" class="header"><a href="#Introduction to Cryptography-Hill cipher">Hill cipher</a></h2></div>
<p>
A block cipher, where you cut text into parts of equal length.
</p>

<p>
Definition:
</p>
<ul>
<li>
ğ“Ÿ = Zm length ğ“µ = ğ“’

<li>
ğ“š = { k | k is invertible ğ“µÃ—ğ“µ matrix with entries in Zm }

<li>
ek(x1...xğ“µ) = (x1...xğ“µ)k = (y...yğ“µ)

<ul>
<li>
right matrix multiplication!!

</ul>
<li>
dk(y) = ykâ»Â¹

</ul>

<div id="Introduction to Cryptography-Affine linear cipher"><h2 id="Affine linear cipher" class="header"><a href="#Introduction to Cryptography-Affine linear cipher">Affine linear cipher</a></h2></div>
<p>
Definition:
</p>
<ul>
<li>
ğ“Ÿ = Zm^ğ“µ = ğ“’

<li>
ğ“š = { (A,b) | A invertible ğ“µÃ—ğ“µ matrix, b âˆˆ Zm^ğ“µ }

<li>
ek(x) = xA+b

<li>
dk(y) = (y-b)Aâ»Â¹

</ul>

<div id="Introduction to Cryptography-Permutation cipher"><h2 id="Permutation cipher" class="header"><a href="#Introduction to Cryptography-Permutation cipher">Permutation cipher</a></h2></div>
<p>
Definition:
</p>
<ul>
<li>
ğ“Ÿ = (Zm)^ğ“µ = ğ“’

<li>
K = { Ï€ permutation of 1,2,...ğ“µ }

<li>
ek(x1...xğ“µ) = (x_Ï€(1)...x_Ï€(ğ“µ))

<li>
dk(y1...yğ“µ) = (y_Ï€â»Â¹(1)...y_Ï€â»Â¹(ğ“µ))

</ul>

<p>
A particular case of the Hill cipher using ğ“µÃ—ğ“µ matrix with a shuffled Iğ“µ.
</p>

<div id="Introduction to Cryptography-Stream ciphers"><h2 id="Stream ciphers" class="header"><a href="#Introduction to Cryptography-Stream ciphers">Stream ciphers</a></h2></div>
<p>
Like block ciphers, but different key for every block.
Key is a stream key, either constructed using an initial key + a rule, or with key together with plaintext.
key may depend on the text.
</p>

<div id="Introduction to Cryptography-Stream ciphers-Synchronous stream ciphers"><h3 id="Synchronous stream ciphers" class="header"><a href="#Introduction to Cryptography-Stream ciphers-Synchronous stream ciphers">Synchronous stream ciphers</a></h3></div>
<ul>
<li>
keystream can be obtained from initial key

<li>
Definition:

<ul>
<li>
ğ“Ÿ finite set of plaintexts

<li>
ğ“’ finite set of ciphertexts

<li>
ğ“š finite set of possible keys

<li>
ğ“› finite set of keystream alphabet

<li>
ğ“” = { ez : ğ“Ÿ â†’ ğ“’ | z âˆˆ ğ“› }

<li>
ğ““ = { dz : ğ“’ â†’ ğ“Ÿ | z âˆˆ ğ“› }

<li>
ez(x) = x+z

<li>
dz(y) = y+z

<li>
generating key stream function: g(k) = z1, z2...zk...

</ul>
</ul>

<div id="Introduction to Cryptography-Stream ciphers-Synchronous stream ciphers-Linear recurrence stream cipher"><h4 id="Linear recurrence stream cipher" class="header"><a href="#Introduction to Cryptography-Stream ciphers-Synchronous stream ciphers-Linear recurrence stream cipher">Linear recurrence stream cipher</a></h4></div>
<p>
Everything is Zâ‚‚.
Max period is 2^ğ“µ -1.
Z_ğ“µ+i = c1 zi + c2 z_i+1 + ... + cğ“µ z_i+ğ“µ-1.
</p>


<div id="Introduction to Cryptography-Stream ciphers-Non-synchronous stream ciphers:"><h3 id="Non-synchronous stream ciphers:" class="header"><a href="#Introduction to Cryptography-Stream ciphers-Non-synchronous stream ciphers:">Non-synchronous stream ciphers:</a></h3></div>
<ul>
<li>
key depends on initial key and plaintext

</ul>

<div id="Introduction to Cryptography-Stream ciphers-Non-synchronous stream ciphers:-Autokey cipher"><h4 id="Autokey cipher" class="header"><a href="#Introduction to Cryptography-Stream ciphers-Non-synchronous stream ciphers:-Autokey cipher">Autokey cipher</a></h4></div>
<p>
Only use the keyword on the first chunk.
Then use plaintext for rest.
</p>

<p>
functions:
</p>
<ul>
<li>
ez(x) = x+z

<li>
dz(y) = y-z

</ul>


<p>
Autokey encrypts different plaintexts using different key streams.
But if there's noise on the channel, shit gets fucked.
</p>

    </div>
</body>
</html>
