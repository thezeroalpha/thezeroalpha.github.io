<html>
<head>
    <link rel="Stylesheet" type="text/css" href="style.css" />
    <title>Logic and Modeling</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <script type="text/javascript" async src="https://cdn.jsdelivr.net/gh/mathjax/MathJax@2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
    <a href="index.html">Index</a>
    <hr>
    <div class="content">
    

<div id="Logic and Modeling"><h1 id="Logic and Modeling" class="header"><a href="#Logic and Modeling">Logic and Modeling</a></h1></div>
<p>
<a href="http://avigad.github.io/logic_and_proof/propositional_logic.html">The book online.</a>
</p>

<div id="Contents" class="toc"><h1 id="Contents">Contents</a></h2></div>
<ul>
<li>
<a href="Logic and Modeling.html#Logic and Modeling-Propositional logic">Propositional logic</a>

<ul>
<li>
<a href="Logic and Modeling.html#Logic and Modeling-Propositional logic-Notation review">Notation review</a>

<li>
<a href="Logic and Modeling.html#Logic and Modeling-Propositional logic-Rules of inference">Rules of inference</a>

<li>
<a href="Logic and Modeling.html#Logic and Modeling-Propositional logic-Forward and backward reasoning">Forward and backward reasoning</a>

<li>
<a href="Logic and Modeling.html#Logic and Modeling-Propositional logic-Proof by contradiction">Proof by contradiction</a>

<li>
<a href="Logic and Modeling.html#Logic and Modeling-Propositional logic-Vocab definitions">Vocab definitions</a>

<li>
<a href="Logic and Modeling.html#Logic and Modeling-Propositional logic-Classical reasoning">Classical reasoning</a>

<li>
<a href="Logic and Modeling.html#Logic and Modeling-Propositional logic-Syntax vs Semantics">Syntax vs Semantics</a>

<li>
<a href="Logic and Modeling.html#Logic and Modeling-Propositional logic-Soundness and completeness">Soundness and completeness</a>

</ul>
<li>
<a href="Logic and Modeling.html#Logic and Modeling-First order logic">First order logic</a>

<ul>
<li>
<a href="Logic and Modeling.html#Logic and Modeling-First order logic-Functions, predicates, relations">Functions, predicates, relations</a>

<li>
<a href="Logic and Modeling.html#Logic and Modeling-First order logic-Quantifiers, binding">Quantifiers, binding</a>

<ul>
<li>
<a href="Logic and Modeling.html#Logic and Modeling-First order logic-Quantifiers, binding-Natural deduction rules">Natural deduction rules</a>

</ul>
<li>
<a href="Logic and Modeling.html#Logic and Modeling-First order logic-Relativization and sorts">Relativization and sorts</a>

<li>
<a href="Logic and Modeling.html#Logic and Modeling-First order logic-Models">Models</a>

<li>
<a href="Logic and Modeling.html#Logic and Modeling-First order logic-Interpreting formulas without quantifiers">Interpreting formulas without quantifiers</a>

<li>
<a href="Logic and Modeling.html#Logic and Modeling-First order logic-Interpretation of formulas with quantifiers and free variables">Interpretation of formulas with quantifiers and free variables</a>

<li>
<a href="Logic and Modeling.html#Logic and Modeling-First order logic-Interpreting terms in model with enironment">Interpreting terms in model with enironment</a>

<li>
<a href="Logic and Modeling.html#Logic and Modeling-First order logic-Semantical entailment in predicate logic">Semantical entailment in predicate logic</a>

<li>
<a href="Logic and Modeling.html#Logic and Modeling-First order logic-Logical equivalence">Logical equivalence</a>

<li>
<a href="Logic and Modeling.html#Logic and Modeling-First order logic-Satisfiability, validity, consistency">Satisfiability, validity, consistency</a>

<li>
<a href="Logic and Modeling.html#Logic and Modeling-First order logic-Translating into predicate logic">Translating into predicate logic</a>

<li>
<a href="Logic and Modeling.html#Logic and Modeling-First order logic-Rules for quantifiers and connectives">Rules for quantifiers and connectives</a>

<li>
<a href="Logic and Modeling.html#Logic and Modeling-First order logic-Semantics of first order logic">Semantics of first order logic</a>

</ul>
<li>
<a href="Logic and Modeling.html#Logic and Modeling-Sets">Sets</a>

<li>
<a href="Logic and Modeling.html#Logic and Modeling-Relations">Relations</a>

<ul>
<li>
<a href="Logic and Modeling.html#Logic and Modeling-Relations-Order types">Order types</a>

</ul>
<li>
<a href="Logic and Modeling.html#Logic and Modeling-Natural numbers &amp; induction">Natural numbers &amp; induction</a>

<ul>
<li>
<a href="Logic and Modeling.html#Logic and Modeling-Natural numbers &amp; induction-Recursive definitions">Recursive definitions</a>

</ul>
</ul>

<div id="Logic and Modeling-Propositional logic"><h2 id="Propositional logic" class="header"><a href="#Logic and Modeling-Propositional logic">Propositional logic</a></h2></div>
<div id="Logic and Modeling-Propositional logic-Notation review"><h3 id="Notation review" class="header"><a href="#Logic and Modeling-Propositional logic-Notation review">Notation review</a></h3></div>
<ul>
<li>
<code>A, B, C</code> -- propositions

<li>
<code>A ∧ B</code> -- conjunction ("and")

<li>
<code>A ∨ B</code> -- disjunction ("or")

<li>
<code>A → B</code> -- implication ("if A then B")

<li>
<code>A ↔ B</code> -- bi-implication ("A iff B")

<li>
<code>¬ A</code> -- negation ("not A")

<li>
<code>⊥</code> -- false, falsum, nonsense, bullshit, the middle finger

</ul>

<div id="Logic and Modeling-Propositional logic-Rules of inference"><h3 id="Rules of inference" class="header"><a href="#Logic and Modeling-Propositional logic-Rules of inference">Rules of inference</a></h3></div>
<p>
"C is a logical consequence of A and B":
</p>

<p>
<img src="img-logic/logical-consequence.png" alt="Logical consequence" />
</p>


<table>
<tr>
<th>
Implication
</th>
<th>
Conjunction
</th>
<th>
Negation
</th>
<th>
Disjunction
</th>
<th>
Bi-implication ("if and only if")
</th>
</tr>
<tr>
<td>
<img src="img-logic/implication-elimination.png" alt="Implication elimination" />
</td>
<td>
<img src="img-logic/conjunction-introduction.png" alt="Conjunction introduction" />
</td>
<td>
<img src="img-logic/negation-hypothetical-reasoning.png" alt="Negation hypothetical reasoning" />
</td>
<td>
<img src="img-logic/disjunction-introduction.png" alt="Disjunction introduction" />
</td>
<td>
<img src="img-logic/bi-implication-introduction.png" alt="Bi-implication introduction" />
</td>
</tr>
<tr>
<td>
<img src="img-logic/hypothesis.png" alt="Hypothesis" />
</td>
<td>
<img src="img-logic/and-elimination.png" alt="And elimination" />
</td>
<td>
<img src="img-logic/negation-elimination.png" alt="Negation elimination" />
</td>
<td>
<img src="img-logic/disjunction-elimination.png" alt="Disjunction elimination" />
</td>
<td>
<img src="img-logic/bi-implication-elimination.png" alt="Bi-implication elimination" />
</td>
</tr>
</table>

<p>
Truth and falsity: from false, you can conclude anything, and from nothing, you can conclude true.
</p>

<p>
<img src="img-logic/falsum-elimination.png" alt="Falsum elimination" />, <img src="img-logic/truth-introduction.png" alt="Truth introduction" />
</p>

<p>
You can also derive this conjunction rule:
</p>

<p>
<img src="img-logic/conjunction-negation-rule.png" alt="Conjunction negation rule" />
</p>

<div id="Logic and Modeling-Propositional logic-Forward and backward reasoning"><h3 id="Forward and backward reasoning" class="header"><a href="#Logic and Modeling-Propositional logic-Forward and backward reasoning">Forward and backward reasoning</a></h3></div>
<p>
Backward reasoning: looking at the goal and seeing what rules need to be applied ("bottom-up")
</p>

<p>
Forward reasoning: starting at some hypotheses/assumptions
</p>

<p>
The general heuristic is to always work backwards, as much as possible. Only once you get stuck should you work from your assumptions or hypotheses.
</p>

<p>
If all else fails, try proof by contradiction.
</p>

<div id="Logic and Modeling-Propositional logic-Proof by contradiction"><h3 id="Proof by contradiction" class="header"><a href="#Logic and Modeling-Propositional logic-Proof by contradiction">Proof by contradiction</a></h3></div>
<p>
Suppose a negation of a formula is true, prove that it's impossible, thereby proving the original formula.
</p>

<p>
<img src="img-logic/proof-by-contradiction.png" alt="Proof by contradiction" />
</p>

<p>
RAA stands for <em>"reductio ad absurdum"</em>
</p>

<div id="Logic and Modeling-Propositional logic-Vocab definitions"><h3 id="Vocab definitions" class="header"><a href="#Logic and Modeling-Propositional logic-Vocab definitions">Vocab definitions</a></h3></div>
<ul>
<li>
derivable: a formula φ is "derivable" if we can prove φ with no global hypotheses (bottom line is φ, everything is closed). Then we write ⊢ φ.

<li>
φ is derivable from hypotheses ψ₁..ψn if we can compute φ assuming ψ₁..ψn

<li>
formulas φ and ψ are logically equivalent if ⊢ φ ↔ ψ

</ul>

<div id="Logic and Modeling-Propositional logic-Classical reasoning"><h3 id="Classical reasoning" class="header"><a href="#Logic and Modeling-Propositional logic-Classical reasoning">Classical reasoning</a></h3></div>
<p>
Principles:
</p>
<ul>
<li>
Proof by contradiction: assume the contradiction, and show false, thereby proving the original.

<li>
Double negation elimination: ¬ ¬ A ↔ A.

<li>
Contrapositive: if A → B, then ¬ B → ¬ A

</ul>

<p>
A general heuristic:
</p>
<ol>
<li>
Work backward from the conclusion, using introduction rules.

<li>
When you run out of stuff to do, work forward with elimination rules.

<li>
If you get stuck, [insert proof by contradiction meme]

</ol>

<div id="Logic and Modeling-Propositional logic-Syntax vs Semantics"><h3 id="Syntax vs Semantics" class="header"><a href="#Logic and Modeling-Propositional logic-Syntax vs Semantics">Syntax vs Semantics</a></h3></div>
<p>
Syntax:
</p>
<ul>
<li>
derivation, proofs

<li>
Γ ⊢ A ("A is derivable from hypotheses in Γ")

</ul>

<p>
Semantics:
</p>
<ul>
<li>
truth and falsity

<li>
truth assignment says which propositional letters are true

<li>
valuation says which formulas are true

</ul>

<div id="Logic and Modeling-Propositional logic-Soundness and completeness"><h3 id="Soundness and completeness" class="header"><a href="#Logic and Modeling-Propositional logic-Soundness and completeness">Soundness and completeness</a></h3></div>
<p>
provable: if there is a formal proof of a formula (syntactic)
</p>

<p>
tautology/valid: if true under any truth assignment (semantic)
</p>

<p>
soundness: if a formula is provable, it is valid (if ⊢ A, then ⊨ A)
</p>

<p>
completeness: if a formula is valid, it is provable (if ⊨ A, then ⊢ A)
</p>

<p>
Proving soundness is easier than proving completeness.
</p>

<p>
A is a logical consequence of Γ if, given any truth assignment that makes every formula in Γ true, A is true.
</p>

<div id="Logic and Modeling-First order logic"><h2 id="First order logic" class="header"><a href="#Logic and Modeling-First order logic">First order logic</a></h2></div>
<div id="Logic and Modeling-First order logic-Functions, predicates, relations"><h3 id="Functions, predicates, relations" class="header"><a href="#Logic and Modeling-First order logic-Functions, predicates, relations">Functions, predicates, relations</a></h3></div>
<p>
functions: take different numbers of arguments, returns a result. e.g. \(mul(x,y)\), \(square(x)\)
</p>

<p>
predicates, relations: takes one or more arguments, is either true or false. e.g. \(even(x)\), \(divides(x,y)\)
</p>

<p>
formulas: say things. make assertions about objects in the domain.
</p>

<div id="Logic and Modeling-First order logic-Quantifiers, binding"><h3 id="Quantifiers, binding" class="header"><a href="#Logic and Modeling-First order logic-Quantifiers, binding">Quantifiers, binding</a></h3></div>
<p>
Quantifiers:
</p>
<ul>
<li>
∀x: "for all x"

<li>
∃x: "there exists an x"

</ul>

<p>
Generally bind tightly: ∀x P ∨ Q == (∀x P) ∨ Q
</p>

<p>
free variable: variable that's not bound
</p>

<p>
sentence: a formula that has no free variables
</p>

<div id="Logic and Modeling-First order logic-Quantifiers, binding-Natural deduction rules"><h4 id="Natural deduction rules" class="header"><a href="#Logic and Modeling-First order logic-Quantifiers, binding-Natural deduction rules">Natural deduction rules</a></h4></div>

<table>
<tr>
<th>
Universal quantification
</th>
<th>
Existential quantification
</th>
<th>
Equality
</th>
</tr>
<tr>
<td>
<img src="img-logic/universal-introduction.png" alt="Universal introduction" />
</td>
<td>
<img src="img-logic/existential-introduction.png" alt="Existential introduction" />
</td>
<td rowspan="2">
<img src="img-logic/equality-rules.png" alt="Equality rules" />
</td>
</tr>
<tr>
<td>
<img src="img-logic/universal-elimination.png" alt="Universal elimination" />
</td>
<td>
<img src="img-logic/existential-elimination.png" alt="Existential elimination" />
</td>
</tr>
</table>


<div id="Logic and Modeling-First order logic-Relativization and sorts"><h3 id="Relativization and sorts" class="header"><a href="#Logic and Modeling-First order logic-Relativization and sorts">Relativization and sorts</a></h3></div>
<p>
You can use implication to relativize quantification (put it into a specific domain). 
</p>

<p>
Universal quantification, e.g. "every prime number greater than two is odd":
</p>

<p>
∀x (prime(x) ∧ x &gt; 2 → odd(x))
</p>

<p>
Existential quantification, e.g. "some woman is strong":
</p>

<p>
∃x (woman(x) ∧ strong(x))
</p>

<ol>
<li>
<span class="todo">TODO</span>: some slides missed here

</ol>

<div id="Logic and Modeling-First order logic-Models"><h3 id="Models" class="header"><a href="#Logic and Modeling-First order logic-Models">Models</a></h3></div>
<p>
Let F be a set of function symbols, P a set of predicate symbols.
</p>

<p>
Model M for (F, P) consists of:
</p>
<ul>
<li>
non-empty set A ("domain", "universe")

<li>
interpretation operation \((\cdot)^M\) for for symbols in F, P

</ul>
          
<p>
Universe A can be any non-empty set.
</p>

<p>
only constraint: f<sup><small>M and P</small></sup>M have same number of arguments as f and P.
</p>

<div id="Logic and Modeling-First order logic-Interpreting formulas without quantifiers"><h3 id="Interpreting formulas without quantifiers" class="header"><a href="#Logic and Modeling-First order logic-Interpreting formulas without quantifiers">Interpreting formulas without quantifiers</a></h3></div>
<p>
Truth defintion for formula Φ without quantifiers and free variables in model M by induction on the structure of Φ:
</p>
<ul>
<li>
M ⊨ ¬Φ ↔ not: M ⊨ Φ ↔ M ⊭ Φ

<li>
M ⊨ Æ∧ Ψ ↔ M ⊨ Φ and M ⊨ Ψ

<li>
M ⊨ Φ ∨ Ψ ↔ M ⊨ Φ or M ⊨ Ψ

<li>
M ⊨ Φ → Ψ : if M ⊨ Φ then M ⊨ Ψ

<li>
M ⊨ P(t₁, .., tn) ↔ (t₁<sup><small>M, ..., tn</small></sup>M) ∈ P^M

</ul>

<p>
Interpretation of terms t^M: 
</p>
<ul>
<li>
if t = c for constant c, then t<sup><small>M = c</small></sup>M

<li>
if t = f(t₁,..., tn), then t<sup><small>M = f</small></sup>M(t₁<sup><small>M,...,tn</small></sup>M)

</ul>

<div id="Logic and Modeling-First order logic-Interpretation of formulas with quantifiers and free variables"><h3 id="Interpretation of formulas with quantifiers and free variables" class="header"><a href="#Logic and Modeling-First order logic-Interpretation of formulas with quantifiers and free variables">Interpretation of formulas with quantifiers and free variables</a></h3></div>
<p>
to interpret free variables, you use an environment.
</p>

<p>
an environment <code>l: var → A</code> (look up function) interprets free variables in the domain
</p>

<div id="Logic and Modeling-First order logic-Interpreting terms in model with enironment"><h3 id="Interpreting terms in model with enironment" class="header"><a href="#Logic and Modeling-First order logic-Interpreting terms in model with enironment">Interpreting terms in model with enironment</a></h3></div>
<p>
terms are built from variables, constants, function symbols
</p>
<ul>
<li>
variables are interpreted according to environment

<li>
cnstants are interpreted according to \((\cdot)^M\)

<li>
function symbols are interpreted according to \((\cdot)^M\)

</ul>


<p>
Truth of formula Φ in model M wiht universe A with respect to environment e is defined by induction on the structure of Φ.
</p>

<p>
Interpretation \(t^{M,l}\) of term t is
</p>

\begin{align}
t^{M, l} = \begin{cases}
            l(x) &amp;&amp;\text{if } t = x \text{ for a variable } x \\
            c^M &amp;&amp;\text{if } t = c \text{ for a constant } c \\
            f^M (t_1^{M, l}, \ldots, t_n^{M, l}) &amp;&amp;\text{if } t = f(t_1, \ldots, t_n)
            \end{cases}
\end{align}
<p>
by induction on term structure.
</p>

<p>
M ⊨l ∀x HI ↔ for all a ∈ A it holds that \( M \models_{l [x \to a]} \phi \)
</p>

<p>
M ⊨l ∃x Φ ↔ for some a ∈ A it holds that \( M \models_{l [x \to a]} \phi \)
</p>

<div id="Logic and Modeling-First order logic-Semantical entailment in predicate logic"><h3 id="Semantical entailment in predicate logic" class="header"><a href="#Logic and Modeling-First order logic-Semantical entailment in predicate logic">Semantical entailment in predicate logic</a></h3></div>
<p>
For all models M and all environments e, 
such that M ⊨l Φ₁ and ... and M ⊨l Φn hold,
it also holds that M ⊨l ψ
</p>

<div id="Logic and Modeling-First order logic-Logical equivalence"><h3 id="Logical equivalence" class="header"><a href="#Logic and Modeling-First order logic-Logical equivalence">Logical equivalence</a></h3></div>
<p>
Formulas φ and ψ are logically equivalent (φ ≡ ψ) if for all models M and environments l, M ⊨l φ ↔ M ⊨l ψ
</p>

<p>
i.e. φ and ψ are true in precisely the same models when interpreted with the same environments.
</p>

<p>
theorem: φ ≡ ψ  ↔ φ ⊨ ψ and ψ ⊨ φ
</p>

<div id="Logic and Modeling-First order logic-Satisfiability, validity, consistency"><h3 id="Satisfiability, validity, consistency" class="header"><a href="#Logic and Modeling-First order logic-Satisfiability, validity, consistency">Satisfiability, validity, consistency</a></h3></div>
<p>
Let φ be a formula, and Γ be a set of formulas.
</p>

<p>
φ is satisfiable iff there is <em>some</em> model M and <em>some</em> environment l such that M ⊨l φ
</p>

<p>
φ is valid iff M ⊨l φ holds for <em>all</em> models M and <em>all</em> environments l in which φ can be checked.
</p>

<p>
Γ is consistent/satisfiable iff there is <em>some</em> model M and <em>some</em> environment l such tat M ⊨l ψ for all ψ ∈ Γ
</p>

<p>
for all formulas φ, ψ: φ ≡ ψ means that φ ↔ ψ is valid
</p>

<div id="Logic and Modeling-First order logic-Translating into predicate logic"><h3 id="Translating into predicate logic" class="header"><a href="#Logic and Modeling-First order logic-Translating into predicate logic">Translating into predicate logic</a></h3></div>
<p>
Example: "Marie and Jan are clever."
</p>

<p>
Specification and model used:
</p>

<p>
two predicates:
</p>
<ul>
<li>
CC(x): x is clever

<li>
LL(x): x has learned logic

</ul>

<p>
two constants:
</p>
<ul>
<li>
m: Marie

<li>
j: Jan

</ul>

<p>
model M:
</p>
<ul>
<li>
domain A = the set of all humans

<li>
C^M = { x ∈ A | x is clever }

<li>
LL^M = { x ∈ A | x has learned logic }

<li>
j^M = Jan

<li>
m^M = Marie

</ul>

<p>
Then:
</p>
<ul>
<li>
"Marie and Jan are clever": C(m) ∧ C(j)

<li>
"Not everybody is clever": ¬∀x C(x)

<li>
"Somebody has learned logic": ∃x LL(x)

<li>
"Not everybody has learned logic, but Marie and Jan have": ¬∀x LL(x) ∧ LL(m) ∧ LL(j)

</ul>

<p>
∀ and →:
</p>
<ul>
<li>
∀x(LL(x) → C(x)): "everyone who has learned logic is clever"

<li>
not the same as ∀x LL(x) → ∀x C(x): "if everyone has learned logic, everyone is clever"

</ul>

<p>
∃ and ∧:
</p>
<ul>
<li>
∃x(L(x) ∧ C(x)): "some logicians are clever"

<li>
not the same as ∃x(L(x) → C(x)): "if someone is a logician, they are clever"

</ul>

<p>
Formulas with free variables express properties and relations:
</p>
<ul>
<li>
no free variables: a sentence

<li>
one free variable: a property

<li>
two or more free variables: a relation

</ul>

<div id="Logic and Modeling-First order logic-Rules for quantifiers and connectives"><h3 id="Rules for quantifiers and connectives" class="header"><a href="#Logic and Modeling-First order logic-Rules for quantifiers and connectives">Rules for quantifiers and connectives</a></h3></div>
<p>
If you move a negation around ∀, it becomes ∃, and vice versa.
</p>

<p>
It also holds that:
</p>
<ul>
<li>
∀x(φ ∧ ψ) ≡ ∀x φ ∧ ∀x ψ

<ul>
<li>
BUT in general doesn't hold for ∨

</ul>
<li>
∃x(φ ∨ ψ) ≡ ∃x φ ∨ ∃x ψ

<ul>
<li>
BUT in general doesn't hold for ∧

</ul>
</ul>

<p>
In general, you can't move quantifiers through an implication.
</p>

<p>
Order of <em>repeated</em> ∀ or ∃ doesn't matter. But if you have <em>both</em> ∃ and ∀, the order is important.
</p>

<div id="Logic and Modeling-First order logic-Semantics of first order logic"><h3 id="Semantics of first order logic" class="header"><a href="#Logic and Modeling-First order logic-Semantics of first order logic">Semantics of first order logic</a></h3></div>
<p>
Interpretation: specifying the meaning of a predicate symbol. 
</p>
<ul>
<li>
unary predicate P: set of elements of domain D for which P is true.

<li>
constant c: an element of domain D

<li>
function f with arity n: function mapping n elements of domain D to another element of D

<li>
relation R with arity n: set of n tuples of elements of domain D for which R is true

</ul>

<p>
You can find the truth value of sentences intuitively.
</p>

<p>
Completeness: if formula A is logical consequence of set of sentences Γ, then A is provable from Γ.
</p>

<p>
Soundness: if A is provable from Γ then A is true in any model of Γ
</p>

<div id="Logic and Modeling-Sets"><h2 id="Sets" class="header"><a href="#Logic and Modeling-Sets">Sets</a></h2></div>
<p>
Recap from logic and sets:
</p>
<ul>
<li>
empty set Ø = {x | false}

<li>
universal set U = {x | true}

<li>
union A ∪ B = {x | x ∈ A or x ∈ B}

<li>
intersection A ∩ B = {x | x ∈ A and x ∈ B}

<li>
complement Ā = {x | x ∉ A}

<li>
difference A \ B = {x | x ∈ A and x ∉ B}

</ul>

<p>
Theorems:
</p>
<ul>
<li>
A ∩ (B ∪ C) = (A ∩ B) ∪ (A ∩ C)

<li>
(A \ B) \ C = A \ (B ∪ C)

</ul>

<div id="Logic and Modeling-Relations"><h2 id="Relations" class="header"><a href="#Logic and Modeling-Relations">Relations</a></h2></div>
<p>
definitions of properties:
</p>
<ul>
<li>
reflexivity: ∀a R(a,a)

<li>
transitivity: ∀a,b,c (R(a,b) ∧ R(b,c) → R(a,c))

<li>
antisymmetry: ∀a,b (R(a,b) ∧ R(b,a) → a = b)

</ul>

<div id="Logic and Modeling-Relations-Order types"><h3 id="Order types" class="header"><a href="#Logic and Modeling-Relations-Order types">Order types</a></h3></div>
<p>
partial order:
</p>
<ul>
<li>
reflexive

<li>
transitive

<li>
antisymmetric

</ul>

<p>
total order:
</p>
<ul>
<li>
partial order

<li>
∀ a,b (R(a,b) ∨ R(b,a))

</ul>

<p>
strict partial order: partial order but irreflexive
</p>

<p>
strict total order:
</p>
<ul>
<li>
strict partial order

<li>
∀ a,b (R(a,b) ∨ (a=b) ∨ R(b,a))

</ul>

<p>
equivalence relation:
</p>
<ul>
<li>
reflexive (∀a, a ≡ A)

<li>
symmetric

<li>
transitive

</ul>

<div id="Logic and Modeling-Natural numbers &amp; induction"><h2 id="Natural numbers &amp; induction" class="header"><a href="#Logic and Modeling-Natural numbers &amp; induction">Natural numbers &amp; induction</a></h2></div>
<p>
Set of natural numbers is N ∈ (0,∞)
</p>

<p>
<span id="Logic and Modeling-Natural numbers &amp; induction-Principle of induction"></span><strong id="Principle of induction">Principle of induction</strong>: let P be a property of natural numbers. Suppose P holds for zero, and whenever P holds for a natural number n, then it holds for its successor n+1. Then P holds for every natural number.
</p>

<p>
As a natural deduction rule:
</p>

<p>
<img src="img-logic/induction-natural-deduction-rule.png" alt="Induction natural deduction rule" />
</p>

<div id="Logic and Modeling-Natural numbers &amp; induction-Recursive definitions"><h3 id="Recursive definitions" class="header"><a href="#Logic and Modeling-Natural numbers &amp; induction-Recursive definitions">Recursive definitions</a></h3></div>
<p>
Let A be any set, suppose a is in A, and g: N × A → A. Then there is a unique function f satisfying:
</p>
<ul>
<li>
f(0) = a

<li>
f(n+1) = g(n, f(n))

</ul>

<p>
Typically to prove something about a recursively defined function is to use induction.
</p>

    </div>
</body>
</html>
